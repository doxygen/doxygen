#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated  by generateDS.py.
#
#
# Command line options:
#   ('--no-dates', '')
#   ('--no-versions', '')
#   ('-f', '')
#   ('-o', '.../addon/doxmlparser/doxmlparser/compound.py')
#
# Command line arguments:
#  .../templates/xml/compound.xsd
#
# Command line:
#  .../generateDS --no-dates --no-versions -f -o ".../addon/doxmlparser/doxmlparser/compound.py" .../templates/xml/compound.xsd
#
# Current working directory (os.getcwd()):
#   doxmlparser
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ModulenotfoundExp_ :
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:

    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""


    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

# # from IPython.Shell import IPShellEmbed
# # args = ''
# # ipshell = IPShellEmbed(args,
# #     banner = 'Dropping into IPython',
# #     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class DoxAccessor(str, Enum):
    RETAIN='retain'
    COPY='copy'
    ASSIGN='assign'
    WEAK='weak'
    STRONG='strong'
    UNRETAINED='unretained'


class DoxAlign(str, Enum):
    LEFT='left'
    RIGHT='right'
    CENTER='center'


class DoxBool(str, Enum):
    YES='yes'
    NO='no'


class DoxCompoundKind(str, Enum):
    CLASS='class'
    STRUCT='struct'
    UNION='union'
    INTERFACE='interface'
    PROTOCOL='protocol'
    CATEGORY='category'
    EXCEPTION='exception'
    SERVICE='service'
    SINGLETON='singleton'
    MODULE='module'
    TYPE='type'
    FILE='file'
    NAMESPACE='namespace'
    GROUP='group'
    PAGE='page'
    EXAMPLE='example'
    DIR='dir'
    CONCEPT='concept'


class DoxGraphRelation(str, Enum):
    INCLUDE='include'
    USAGE='usage'
    TEMPLATEINSTANCE='template-instance'
    PUBLICINHERITANCE='public-inheritance'
    PROTECTEDINHERITANCE='protected-inheritance'
    PRIVATEINHERITANCE='private-inheritance'
    TYPECONSTRAINT='type-constraint'


class DoxHighlightClass(str, Enum):
    COMMENT='comment'
    NORMAL='normal'
    PREPROCESSOR='preprocessor'
    KEYWORD='keyword'
    KEYWORDTYPE='keywordtype'
    KEYWORDFLOW='keywordflow'
    STRINGLITERAL='stringliteral'
    XMLCDATA='xmlcdata'
    CHARLITERAL='charliteral'
    VHDLKEYWORD='vhdlkeyword'
    VHDLLOGIC='vhdllogic'
    VHDLCHAR='vhdlchar'
    VHDLDIGIT='vhdldigit'


class DoxImageKind(str, Enum):
    HTML='html'
    LATEX='latex'
    DOCBOOK='docbook'
    RTF='rtf'
    XML='xml'


class DoxLanguage(str, Enum):
    UNKNOWN='Unknown'
    IDL='IDL'
    JAVA='Java'
    C='C#'
    D='D'
    PHP='PHP'
    OBJECTIVEC='Objective-C'
    C_1='C++'
    JAVA_SCRIPT='JavaScript'
    PYTHON='Python'
    FORTRAN='Fortran'
    VHDL='VHDL'
    XML='XML'
    SQL='SQL'
    MARKDOWN='Markdown'
    SLICE='Slice'
    LEX='Lex'


class DoxMemberKind(str, Enum):
    DEFINE='define'
    PROPERTY='property'
    EVENT='event'
    VARIABLE='variable'
    TYPEDEF='typedef'
    ENUM='enum'
    FUNCTION='function'
    SIGNAL='signal'
    PROTOTYPE='prototype'
    FRIEND='friend'
    DCOP='dcop'
    SLOT='slot'
    INTERFACE='interface'
    SERVICE='service'


class DoxOlType(str, Enum):
    _1='1'
    A='a'
    A_1='A'
    I='i'
    I_1='I'


class DoxParamDir(str, Enum):
    IN='in'
    OUT='out'
    INOUT='inout'


class DoxParamListKind(str, Enum):
    PARAM='param'
    RETVAL='retval'
    EXCEPTION='exception'
    TEMPLATEPARAM='templateparam'


class DoxPlantumlEngine(str, Enum):
    UML='uml'
    BPM='bpm'
    WIRE='wire'
    DOT='dot'
    DITAA='ditaa'
    SALT='salt'
    MATH='math'
    LATEX='latex'
    GANTT='gantt'
    MINDMAP='mindmap'
    WBS='wbs'
    YAML='yaml'
    CREOLE='creole'
    JSON='json'
    FLOW='flow'
    BOARD='board'
    GIT='git'
    HCL='hcl'
    REGEX='regex'
    EBNF='ebnf'


class DoxProtectionKind(str, Enum):
    PUBLIC='public'
    PROTECTED='protected'
    PRIVATE='private'
    PACKAGE='package'


class DoxRefKind(str, Enum):
    COMPOUND='compound'
    MEMBER='member'


class DoxRefQualifierKind(str, Enum):
    LVALUE='lvalue'
    RVALUE='rvalue'


class DoxSectionKind(str, Enum):
    USERDEFINED='user-defined'
    PUBLICTYPE='public-type'
    PUBLICFUNC='public-func'
    PUBLICATTRIB='public-attrib'
    PUBLICSLOT='public-slot'
    SIGNAL='signal'
    DCOPFUNC='dcop-func'
    PROPERTY='property'
    EVENT='event'
    PUBLICSTATICFUNC='public-static-func'
    PUBLICSTATICATTRIB='public-static-attrib'
    PROTECTEDTYPE='protected-type'
    PROTECTEDFUNC='protected-func'
    PROTECTEDATTRIB='protected-attrib'
    PROTECTEDSLOT='protected-slot'
    PROTECTEDSTATICFUNC='protected-static-func'
    PROTECTEDSTATICATTRIB='protected-static-attrib'
    PACKAGETYPE='package-type'
    PACKAGEFUNC='package-func'
    PACKAGEATTRIB='package-attrib'
    PACKAGESTATICFUNC='package-static-func'
    PACKAGESTATICATTRIB='package-static-attrib'
    PRIVATETYPE='private-type'
    PRIVATEFUNC='private-func'
    PRIVATEATTRIB='private-attrib'
    PRIVATESLOT='private-slot'
    PRIVATESTATICFUNC='private-static-func'
    PRIVATESTATICATTRIB='private-static-attrib'
    FRIEND='friend'
    RELATED='related'
    DEFINE='define'
    PROTOTYPE='prototype'
    TYPEDEF='typedef'
    ENUM='enum'
    FUNC='func'
    VAR='var'


class DoxSimpleSectKind(str, Enum):
    SEE='see'
    RETURN='return'
    AUTHOR='author'
    AUTHORS='authors'
    VERSION='version'
    SINCE='since'
    DATE='date'
    NOTE='note'
    WARNING='warning'
    PRE='pre'
    POST='post'
    COPYRIGHT='copyright'
    INVARIANT='invariant'
    REMARK='remark'
    ATTENTION='attention'
    PAR='par'
    RCS='rcs'


class DoxVerticalAlign(str, Enum):
    BOTTOM='bottom'
    TOP='top'
    MIDDLE='middle'


class DoxVirtualKind(str, Enum):
    NONVIRTUAL='non-virtual'
    VIRTUAL='virtual'
    PUREVIRTUAL='pure-virtual'


class MemberKind(str, Enum):
    DEFINE='define'
    PROPERTY='property'
    EVENT='event'
    VARIABLE='variable'
    TYPEDEF='typedef'
    ENUM='enum'
    ENUMVALUE='enumvalue'
    FUNCTION='function'
    SIGNAL='signal'
    PROTOTYPE='prototype'
    FRIEND='friend'
    DCOP='dcop'
    SLOT='slot'


class DoxygenType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, version=None, lang=None, compounddef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.lang = _cast(None, lang)
        self.lang_nsprefix_ = None
        if compounddef is None:
            self.compounddef = []
        else:
            self.compounddef = compounddef
        self.compounddef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoxygenType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoxygenType.subclass:
            return DoxygenType.subclass(*args_, **kwargs_)
        else:
            return DoxygenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_compounddef(self):
        return self.compounddef
    def set_compounddef(self, compounddef):
        self.compounddef = compounddef
    def add_compounddef(self, value):
        self.compounddef.append(value)
    def insert_compounddef_at(self, index, value):
        self.compounddef.insert(index, value)
    def replace_compounddef_at(self, index, value):
        self.compounddef[index] = value
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_lang(self):
        return self.lang
    def set_lang(self, lang):
        self.lang = lang
    def validate_DoxVersionNumber(self, value):
        # Validate type DoxVersionNumber, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_DoxVersionNumber_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_DoxVersionNumber_patterns_, ))
    validate_DoxVersionNumber_patterns_ = [['^(\\d+\\.\\d+.*)$']]
    def hasContent_(self):
        if (
            self.compounddef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DoxygenType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DoxygenType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DoxygenType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DoxygenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DoxygenType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DoxygenType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' xml:lang=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lang), input_name='lang')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DoxygenType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for compounddef_ in self.compounddef:
            namespaceprefix_ = self.compounddef_nsprefix_ + ':' if (UseCapturedNS_ and self.compounddef_nsprefix_) else ''
            compounddef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='compounddef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
            self.validate_DoxVersionNumber(self.version)    # validate type DoxVersionNumber
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'compounddef':
            obj_ = compounddefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.compounddef.append(obj_)
            obj_.original_tagname_ = 'compounddef'
# end class DoxygenType


class compounddefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, kind=None, language=None, prot=None, final=None, inline=None, sealed=None, abstract=None, compoundname=None, title=None, basecompoundref=None, derivedcompoundref=None, includes=None, includedby=None, incdepgraph=None, invincdepgraph=None, innerdir=None, innerfile=None, innerclass=None, innerconcept=None, innernamespace=None, innerpage=None, innergroup=None, qualifier=None, templateparamlist=None, sectiondef=None, tableofcontents=None, requiresclause=None, initializer=None, briefdescription=None, detaileddescription=None, inheritancegraph=None, collaborationgraph=None, programlisting=None, location=None, listofallmembers=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.kind = _cast(None, kind)
        self.kind_nsprefix_ = None
        self.language = _cast(None, language)
        self.language_nsprefix_ = None
        self.prot = _cast(None, prot)
        self.prot_nsprefix_ = None
        self.final = _cast(None, final)
        self.final_nsprefix_ = None
        self.inline = _cast(None, inline)
        self.inline_nsprefix_ = None
        self.sealed = _cast(None, sealed)
        self.sealed_nsprefix_ = None
        self.abstract = _cast(None, abstract)
        self.abstract_nsprefix_ = None
        self.compoundname = compoundname
        self.compoundname_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if basecompoundref is None:
            self.basecompoundref = []
        else:
            self.basecompoundref = basecompoundref
        self.basecompoundref_nsprefix_ = None
        if derivedcompoundref is None:
            self.derivedcompoundref = []
        else:
            self.derivedcompoundref = derivedcompoundref
        self.derivedcompoundref_nsprefix_ = None
        if includes is None:
            self.includes = []
        else:
            self.includes = includes
        self.includes_nsprefix_ = None
        if includedby is None:
            self.includedby = []
        else:
            self.includedby = includedby
        self.includedby_nsprefix_ = None
        self.incdepgraph = incdepgraph
        self.incdepgraph_nsprefix_ = None
        self.invincdepgraph = invincdepgraph
        self.invincdepgraph_nsprefix_ = None
        if innerdir is None:
            self.innerdir = []
        else:
            self.innerdir = innerdir
        self.innerdir_nsprefix_ = None
        if innerfile is None:
            self.innerfile = []
        else:
            self.innerfile = innerfile
        self.innerfile_nsprefix_ = None
        if innerclass is None:
            self.innerclass = []
        else:
            self.innerclass = innerclass
        self.innerclass_nsprefix_ = None
        if innerconcept is None:
            self.innerconcept = []
        else:
            self.innerconcept = innerconcept
        self.innerconcept_nsprefix_ = None
        if innernamespace is None:
            self.innernamespace = []
        else:
            self.innernamespace = innernamespace
        self.innernamespace_nsprefix_ = None
        if innerpage is None:
            self.innerpage = []
        else:
            self.innerpage = innerpage
        self.innerpage_nsprefix_ = None
        if innergroup is None:
            self.innergroup = []
        else:
            self.innergroup = innergroup
        self.innergroup_nsprefix_ = None
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        self.templateparamlist = templateparamlist
        self.templateparamlist_nsprefix_ = None
        if sectiondef is None:
            self.sectiondef = []
        else:
            self.sectiondef = sectiondef
        self.sectiondef_nsprefix_ = None
        self.tableofcontents = tableofcontents
        self.tableofcontents_nsprefix_ = None
        self.requiresclause = requiresclause
        self.requiresclause_nsprefix_ = None
        self.initializer = initializer
        self.initializer_nsprefix_ = None
        self.briefdescription = briefdescription
        self.briefdescription_nsprefix_ = None
        self.detaileddescription = detaileddescription
        self.detaileddescription_nsprefix_ = None
        self.inheritancegraph = inheritancegraph
        self.inheritancegraph_nsprefix_ = None
        self.collaborationgraph = collaborationgraph
        self.collaborationgraph_nsprefix_ = None
        self.programlisting = programlisting
        self.programlisting_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
        self.listofallmembers = listofallmembers
        self.listofallmembers_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, compounddefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if compounddefType.subclass:
            return compounddefType.subclass(*args_, **kwargs_)
        else:
            return compounddefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_compoundname(self):
        return self.compoundname
    def set_compoundname(self, compoundname):
        self.compoundname = compoundname
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_basecompoundref(self):
        return self.basecompoundref
    def set_basecompoundref(self, basecompoundref):
        self.basecompoundref = basecompoundref
    def add_basecompoundref(self, value):
        self.basecompoundref.append(value)
    def insert_basecompoundref_at(self, index, value):
        self.basecompoundref.insert(index, value)
    def replace_basecompoundref_at(self, index, value):
        self.basecompoundref[index] = value
    def get_derivedcompoundref(self):
        return self.derivedcompoundref
    def set_derivedcompoundref(self, derivedcompoundref):
        self.derivedcompoundref = derivedcompoundref
    def add_derivedcompoundref(self, value):
        self.derivedcompoundref.append(value)
    def insert_derivedcompoundref_at(self, index, value):
        self.derivedcompoundref.insert(index, value)
    def replace_derivedcompoundref_at(self, index, value):
        self.derivedcompoundref[index] = value
    def get_includes(self):
        return self.includes
    def set_includes(self, includes):
        self.includes = includes
    def add_includes(self, value):
        self.includes.append(value)
    def insert_includes_at(self, index, value):
        self.includes.insert(index, value)
    def replace_includes_at(self, index, value):
        self.includes[index] = value
    def get_includedby(self):
        return self.includedby
    def set_includedby(self, includedby):
        self.includedby = includedby
    def add_includedby(self, value):
        self.includedby.append(value)
    def insert_includedby_at(self, index, value):
        self.includedby.insert(index, value)
    def replace_includedby_at(self, index, value):
        self.includedby[index] = value
    def get_incdepgraph(self):
        return self.incdepgraph
    def set_incdepgraph(self, incdepgraph):
        self.incdepgraph = incdepgraph
    def get_invincdepgraph(self):
        return self.invincdepgraph
    def set_invincdepgraph(self, invincdepgraph):
        self.invincdepgraph = invincdepgraph
    def get_innerdir(self):
        return self.innerdir
    def set_innerdir(self, innerdir):
        self.innerdir = innerdir
    def add_innerdir(self, value):
        self.innerdir.append(value)
    def insert_innerdir_at(self, index, value):
        self.innerdir.insert(index, value)
    def replace_innerdir_at(self, index, value):
        self.innerdir[index] = value
    def get_innerfile(self):
        return self.innerfile
    def set_innerfile(self, innerfile):
        self.innerfile = innerfile
    def add_innerfile(self, value):
        self.innerfile.append(value)
    def insert_innerfile_at(self, index, value):
        self.innerfile.insert(index, value)
    def replace_innerfile_at(self, index, value):
        self.innerfile[index] = value
    def get_innerclass(self):
        return self.innerclass
    def set_innerclass(self, innerclass):
        self.innerclass = innerclass
    def add_innerclass(self, value):
        self.innerclass.append(value)
    def insert_innerclass_at(self, index, value):
        self.innerclass.insert(index, value)
    def replace_innerclass_at(self, index, value):
        self.innerclass[index] = value
    def get_innerconcept(self):
        return self.innerconcept
    def set_innerconcept(self, innerconcept):
        self.innerconcept = innerconcept
    def add_innerconcept(self, value):
        self.innerconcept.append(value)
    def insert_innerconcept_at(self, index, value):
        self.innerconcept.insert(index, value)
    def replace_innerconcept_at(self, index, value):
        self.innerconcept[index] = value
    def get_innernamespace(self):
        return self.innernamespace
    def set_innernamespace(self, innernamespace):
        self.innernamespace = innernamespace
    def add_innernamespace(self, value):
        self.innernamespace.append(value)
    def insert_innernamespace_at(self, index, value):
        self.innernamespace.insert(index, value)
    def replace_innernamespace_at(self, index, value):
        self.innernamespace[index] = value
    def get_innerpage(self):
        return self.innerpage
    def set_innerpage(self, innerpage):
        self.innerpage = innerpage
    def add_innerpage(self, value):
        self.innerpage.append(value)
    def insert_innerpage_at(self, index, value):
        self.innerpage.insert(index, value)
    def replace_innerpage_at(self, index, value):
        self.innerpage[index] = value
    def get_innergroup(self):
        return self.innergroup
    def set_innergroup(self, innergroup):
        self.innergroup = innergroup
    def add_innergroup(self, value):
        self.innergroup.append(value)
    def insert_innergroup_at(self, index, value):
        self.innergroup.insert(index, value)
    def replace_innergroup_at(self, index, value):
        self.innergroup[index] = value
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def add_qualifier(self, value):
        self.qualifier.append(value)
    def insert_qualifier_at(self, index, value):
        self.qualifier.insert(index, value)
    def replace_qualifier_at(self, index, value):
        self.qualifier[index] = value
    def get_templateparamlist(self):
        return self.templateparamlist
    def set_templateparamlist(self, templateparamlist):
        self.templateparamlist = templateparamlist
    def get_sectiondef(self):
        return self.sectiondef
    def set_sectiondef(self, sectiondef):
        self.sectiondef = sectiondef
    def add_sectiondef(self, value):
        self.sectiondef.append(value)
    def insert_sectiondef_at(self, index, value):
        self.sectiondef.insert(index, value)
    def replace_sectiondef_at(self, index, value):
        self.sectiondef[index] = value
    def get_tableofcontents(self):
        return self.tableofcontents
    def set_tableofcontents(self, tableofcontents):
        self.tableofcontents = tableofcontents
    def get_requiresclause(self):
        return self.requiresclause
    def set_requiresclause(self, requiresclause):
        self.requiresclause = requiresclause
    def get_initializer(self):
        return self.initializer
    def set_initializer(self, initializer):
        self.initializer = initializer
    def get_briefdescription(self):
        return self.briefdescription
    def set_briefdescription(self, briefdescription):
        self.briefdescription = briefdescription
    def get_detaileddescription(self):
        return self.detaileddescription
    def set_detaileddescription(self, detaileddescription):
        self.detaileddescription = detaileddescription
    def get_inheritancegraph(self):
        return self.inheritancegraph
    def set_inheritancegraph(self, inheritancegraph):
        self.inheritancegraph = inheritancegraph
    def get_collaborationgraph(self):
        return self.collaborationgraph
    def set_collaborationgraph(self, collaborationgraph):
        self.collaborationgraph = collaborationgraph
    def get_programlisting(self):
        return self.programlisting
    def set_programlisting(self, programlisting):
        self.programlisting = programlisting
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_listofallmembers(self):
        return self.listofallmembers
    def set_listofallmembers(self, listofallmembers):
        self.listofallmembers = listofallmembers
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_prot(self):
        return self.prot
    def set_prot(self, prot):
        self.prot = prot
    def get_final(self):
        return self.final
    def set_final(self, final):
        self.final = final
    def get_inline(self):
        return self.inline
    def set_inline(self, inline):
        self.inline = inline
    def get_sealed(self):
        return self.sealed
    def set_sealed(self, sealed):
        self.sealed = sealed
    def get_abstract(self):
        return self.abstract
    def set_abstract(self, abstract):
        self.abstract = abstract
    def validate_DoxCompoundKind(self, value):
        # Validate type DoxCompoundKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['class', 'struct', 'union', 'interface', 'protocol', 'category', 'exception', 'service', 'singleton', 'module', 'type', 'file', 'namespace', 'group', 'page', 'example', 'dir', 'concept']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxCompoundKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxLanguage(self, value):
        # Validate type DoxLanguage, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['Unknown', 'IDL', 'Java', 'C#', 'D', 'PHP', 'Objective-C', 'C++', 'JavaScript', 'Python', 'Fortran', 'VHDL', 'XML', 'SQL', 'Markdown', 'Slice', 'Lex']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxLanguage' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxProtectionKind(self, value):
        # Validate type DoxProtectionKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['public', 'protected', 'private', 'package']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxProtectionKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxBool(self, value):
        # Validate type DoxBool, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxBool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.compoundname is not None or
            self.title is not None or
            self.basecompoundref or
            self.derivedcompoundref or
            self.includes or
            self.includedby or
            self.incdepgraph is not None or
            self.invincdepgraph is not None or
            self.innerdir or
            self.innerfile or
            self.innerclass or
            self.innerconcept or
            self.innernamespace or
            self.innerpage or
            self.innergroup or
            self.qualifier or
            self.templateparamlist is not None or
            self.sectiondef or
            self.tableofcontents is not None or
            self.requiresclause is not None or
            self.initializer is not None or
            self.briefdescription is not None or
            self.detaileddescription is not None or
            self.inheritancegraph is not None or
            self.collaborationgraph is not None or
            self.programlisting is not None or
            self.location is not None or
            self.listofallmembers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='compounddefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('compounddefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'compounddefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='compounddefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='compounddefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='compounddefType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')), ))
        if self.prot is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            outfile.write(' prot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prot), input_name='prot')), ))
        if self.final is not None and 'final' not in already_processed:
            already_processed.add('final')
            outfile.write(' final=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.final), input_name='final')), ))
        if self.inline is not None and 'inline' not in already_processed:
            already_processed.add('inline')
            outfile.write(' inline=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inline), input_name='inline')), ))
        if self.sealed is not None and 'sealed' not in already_processed:
            already_processed.add('sealed')
            outfile.write(' sealed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sealed), input_name='sealed')), ))
        if self.abstract is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            outfile.write(' abstract=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.abstract), input_name='abstract')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='compounddefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.compoundname is not None:
            namespaceprefix_ = self.compoundname_nsprefix_ + ':' if (UseCapturedNS_ and self.compoundname_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompoundname>%s</%scompoundname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.compoundname), input_name='compoundname')), namespaceprefix_ , eol_))
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        for basecompoundref_ in self.basecompoundref:
            namespaceprefix_ = self.basecompoundref_nsprefix_ + ':' if (UseCapturedNS_ and self.basecompoundref_nsprefix_) else ''
            basecompoundref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='basecompoundref', pretty_print=pretty_print)
        for derivedcompoundref_ in self.derivedcompoundref:
            namespaceprefix_ = self.derivedcompoundref_nsprefix_ + ':' if (UseCapturedNS_ and self.derivedcompoundref_nsprefix_) else ''
            derivedcompoundref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='derivedcompoundref', pretty_print=pretty_print)
        for includes_ in self.includes:
            namespaceprefix_ = self.includes_nsprefix_ + ':' if (UseCapturedNS_ and self.includes_nsprefix_) else ''
            includes_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='includes', pretty_print=pretty_print)
        for includedby_ in self.includedby:
            namespaceprefix_ = self.includedby_nsprefix_ + ':' if (UseCapturedNS_ and self.includedby_nsprefix_) else ''
            includedby_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='includedby', pretty_print=pretty_print)
        if self.incdepgraph is not None:
            namespaceprefix_ = self.incdepgraph_nsprefix_ + ':' if (UseCapturedNS_ and self.incdepgraph_nsprefix_) else ''
            self.incdepgraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='incdepgraph', pretty_print=pretty_print)
        if self.invincdepgraph is not None:
            namespaceprefix_ = self.invincdepgraph_nsprefix_ + ':' if (UseCapturedNS_ and self.invincdepgraph_nsprefix_) else ''
            self.invincdepgraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='invincdepgraph', pretty_print=pretty_print)
        for innerdir_ in self.innerdir:
            namespaceprefix_ = self.innerdir_nsprefix_ + ':' if (UseCapturedNS_ and self.innerdir_nsprefix_) else ''
            innerdir_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='innerdir', pretty_print=pretty_print)
        for innerfile_ in self.innerfile:
            namespaceprefix_ = self.innerfile_nsprefix_ + ':' if (UseCapturedNS_ and self.innerfile_nsprefix_) else ''
            innerfile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='innerfile', pretty_print=pretty_print)
        for innerclass_ in self.innerclass:
            namespaceprefix_ = self.innerclass_nsprefix_ + ':' if (UseCapturedNS_ and self.innerclass_nsprefix_) else ''
            innerclass_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='innerclass', pretty_print=pretty_print)
        for innerconcept_ in self.innerconcept:
            namespaceprefix_ = self.innerconcept_nsprefix_ + ':' if (UseCapturedNS_ and self.innerconcept_nsprefix_) else ''
            innerconcept_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='innerconcept', pretty_print=pretty_print)
        for innernamespace_ in self.innernamespace:
            namespaceprefix_ = self.innernamespace_nsprefix_ + ':' if (UseCapturedNS_ and self.innernamespace_nsprefix_) else ''
            innernamespace_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='innernamespace', pretty_print=pretty_print)
        for innerpage_ in self.innerpage:
            namespaceprefix_ = self.innerpage_nsprefix_ + ':' if (UseCapturedNS_ and self.innerpage_nsprefix_) else ''
            innerpage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='innerpage', pretty_print=pretty_print)
        for innergroup_ in self.innergroup:
            namespaceprefix_ = self.innergroup_nsprefix_ + ':' if (UseCapturedNS_ and self.innergroup_nsprefix_) else ''
            innergroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='innergroup', pretty_print=pretty_print)
        for qualifier_ in self.qualifier:
            namespaceprefix_ = self.qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squalifier>%s</%squalifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(qualifier_), input_name='qualifier')), namespaceprefix_ , eol_))
        if self.templateparamlist is not None:
            namespaceprefix_ = self.templateparamlist_nsprefix_ + ':' if (UseCapturedNS_ and self.templateparamlist_nsprefix_) else ''
            self.templateparamlist.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateparamlist', pretty_print=pretty_print)
        for sectiondef_ in self.sectiondef:
            namespaceprefix_ = self.sectiondef_nsprefix_ + ':' if (UseCapturedNS_ and self.sectiondef_nsprefix_) else ''
            sectiondef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sectiondef', pretty_print=pretty_print)
        if self.tableofcontents is not None:
            namespaceprefix_ = self.tableofcontents_nsprefix_ + ':' if (UseCapturedNS_ and self.tableofcontents_nsprefix_) else ''
            self.tableofcontents.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tableofcontents', pretty_print=pretty_print)
        if self.requiresclause is not None:
            namespaceprefix_ = self.requiresclause_nsprefix_ + ':' if (UseCapturedNS_ and self.requiresclause_nsprefix_) else ''
            self.requiresclause.export(outfile, level, namespaceprefix_, namespacedef_='', name_='requiresclause', pretty_print=pretty_print)
        if self.initializer is not None:
            namespaceprefix_ = self.initializer_nsprefix_ + ':' if (UseCapturedNS_ and self.initializer_nsprefix_) else ''
            self.initializer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='initializer', pretty_print=pretty_print)
        if self.briefdescription is not None:
            namespaceprefix_ = self.briefdescription_nsprefix_ + ':' if (UseCapturedNS_ and self.briefdescription_nsprefix_) else ''
            self.briefdescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='briefdescription', pretty_print=pretty_print)
        if self.detaileddescription is not None:
            namespaceprefix_ = self.detaileddescription_nsprefix_ + ':' if (UseCapturedNS_ and self.detaileddescription_nsprefix_) else ''
            self.detaileddescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detaileddescription', pretty_print=pretty_print)
        if self.inheritancegraph is not None:
            namespaceprefix_ = self.inheritancegraph_nsprefix_ + ':' if (UseCapturedNS_ and self.inheritancegraph_nsprefix_) else ''
            self.inheritancegraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inheritancegraph', pretty_print=pretty_print)
        if self.collaborationgraph is not None:
            namespaceprefix_ = self.collaborationgraph_nsprefix_ + ':' if (UseCapturedNS_ and self.collaborationgraph_nsprefix_) else ''
            self.collaborationgraph.export(outfile, level, namespaceprefix_, namespacedef_='', name_='collaborationgraph', pretty_print=pretty_print)
        if self.programlisting is not None:
            namespaceprefix_ = self.programlisting_nsprefix_ + ':' if (UseCapturedNS_ and self.programlisting_nsprefix_) else ''
            self.programlisting.export(outfile, level, namespaceprefix_, namespacedef_='', name_='programlisting', pretty_print=pretty_print)
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
        if self.listofallmembers is not None:
            namespaceprefix_ = self.listofallmembers_nsprefix_ + ':' if (UseCapturedNS_ and self.listofallmembers_nsprefix_) else ''
            self.listofallmembers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listofallmembers', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.validate_DoxCompoundKind(self.kind)    # validate type DoxCompoundKind
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
            self.validate_DoxLanguage(self.language)    # validate type DoxLanguage
        value = find_attr_value_('prot', node)
        if value is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            self.prot = value
            self.validate_DoxProtectionKind(self.prot)    # validate type DoxProtectionKind
        value = find_attr_value_('final', node)
        if value is not None and 'final' not in already_processed:
            already_processed.add('final')
            self.final = value
            self.validate_DoxBool(self.final)    # validate type DoxBool
        value = find_attr_value_('inline', node)
        if value is not None and 'inline' not in already_processed:
            already_processed.add('inline')
            self.inline = value
            self.validate_DoxBool(self.inline)    # validate type DoxBool
        value = find_attr_value_('sealed', node)
        if value is not None and 'sealed' not in already_processed:
            already_processed.add('sealed')
            self.sealed = value
            self.validate_DoxBool(self.sealed)    # validate type DoxBool
        value = find_attr_value_('abstract', node)
        if value is not None and 'abstract' not in already_processed:
            already_processed.add('abstract')
            self.abstract = value
            self.validate_DoxBool(self.abstract)    # validate type DoxBool
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'compoundname':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'compoundname')
            value_ = self.gds_validate_string(value_, node, 'compoundname')
            self.compoundname = value_
            self.compoundname_nsprefix_ = child_.prefix
        elif nodeName_ == 'title':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'title')
            value_ = self.gds_validate_string(value_, node, 'title')
            self.title = value_
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'basecompoundref':
            obj_ = compoundRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.basecompoundref.append(obj_)
            obj_.original_tagname_ = 'basecompoundref'
        elif nodeName_ == 'derivedcompoundref':
            obj_ = compoundRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.derivedcompoundref.append(obj_)
            obj_.original_tagname_ = 'derivedcompoundref'
        elif nodeName_ == 'includes':
            obj_ = incType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.includes.append(obj_)
            obj_.original_tagname_ = 'includes'
        elif nodeName_ == 'includedby':
            obj_ = incType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.includedby.append(obj_)
            obj_.original_tagname_ = 'includedby'
        elif nodeName_ == 'incdepgraph':
            obj_ = graphType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.incdepgraph = obj_
            obj_.original_tagname_ = 'incdepgraph'
        elif nodeName_ == 'invincdepgraph':
            obj_ = graphType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.invincdepgraph = obj_
            obj_.original_tagname_ = 'invincdepgraph'
        elif nodeName_ == 'innerdir':
            obj_ = refType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.innerdir.append(obj_)
            obj_.original_tagname_ = 'innerdir'
        elif nodeName_ == 'innerfile':
            obj_ = refType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.innerfile.append(obj_)
            obj_.original_tagname_ = 'innerfile'
        elif nodeName_ == 'innerclass':
            obj_ = refType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.innerclass.append(obj_)
            obj_.original_tagname_ = 'innerclass'
        elif nodeName_ == 'innerconcept':
            obj_ = refType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.innerconcept.append(obj_)
            obj_.original_tagname_ = 'innerconcept'
        elif nodeName_ == 'innernamespace':
            obj_ = refType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.innernamespace.append(obj_)
            obj_.original_tagname_ = 'innernamespace'
        elif nodeName_ == 'innerpage':
            obj_ = refType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.innerpage.append(obj_)
            obj_.original_tagname_ = 'innerpage'
        elif nodeName_ == 'innergroup':
            obj_ = refType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.innergroup.append(obj_)
            obj_.original_tagname_ = 'innergroup'
        elif nodeName_ == 'qualifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qualifier')
            value_ = self.gds_validate_string(value_, node, 'qualifier')
            self.qualifier.append(value_)
            self.qualifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'templateparamlist':
            obj_ = templateparamlistType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateparamlist = obj_
            obj_.original_tagname_ = 'templateparamlist'
        elif nodeName_ == 'sectiondef':
            obj_ = sectiondefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sectiondef.append(obj_)
            obj_.original_tagname_ = 'sectiondef'
        elif nodeName_ == 'tableofcontents':
            obj_ = tableofcontentsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tableofcontents = obj_
            obj_.original_tagname_ = 'tableofcontents'
        elif nodeName_ == 'requiresclause':
            obj_ = linkedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.requiresclause = obj_
            obj_.original_tagname_ = 'requiresclause'
        elif nodeName_ == 'initializer':
            obj_ = linkedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.initializer = obj_
            obj_.original_tagname_ = 'initializer'
        elif nodeName_ == 'briefdescription':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.briefdescription = obj_
            obj_.original_tagname_ = 'briefdescription'
        elif nodeName_ == 'detaileddescription':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.detaileddescription = obj_
            obj_.original_tagname_ = 'detaileddescription'
        elif nodeName_ == 'inheritancegraph':
            obj_ = graphType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inheritancegraph = obj_
            obj_.original_tagname_ = 'inheritancegraph'
        elif nodeName_ == 'collaborationgraph':
            obj_ = graphType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.collaborationgraph = obj_
            obj_.original_tagname_ = 'collaborationgraph'
        elif nodeName_ == 'programlisting':
            obj_ = listingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.programlisting = obj_
            obj_.original_tagname_ = 'programlisting'
        elif nodeName_ == 'location':
            obj_ = locationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'listofallmembers':
            obj_ = listofallmembersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listofallmembers = obj_
            obj_.original_tagname_ = 'listofallmembers'
# end class compounddefType


class qualifier(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qualifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qualifier.subclass:
            return qualifier.subclass(*args_, **kwargs_)
        else:
            return qualifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='qualifier', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qualifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'qualifier':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='qualifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='qualifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='qualifier'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='qualifier', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class qualifier


class listofallmembersType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, member=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if member is None:
            self.member = []
        else:
            self.member = member
        self.member_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listofallmembersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listofallmembersType.subclass:
            return listofallmembersType.subclass(*args_, **kwargs_)
        else:
            return listofallmembersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_member(self):
        return self.member
    def set_member(self, member):
        self.member = member
    def add_member(self, value):
        self.member.append(value)
    def insert_member_at(self, index, value):
        self.member.insert(index, value)
    def replace_member_at(self, index, value):
        self.member[index] = value
    def hasContent_(self):
        if (
            self.member
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listofallmembersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listofallmembersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'listofallmembersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listofallmembersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listofallmembersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listofallmembersType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listofallmembersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for member_ in self.member:
            namespaceprefix_ = self.member_nsprefix_ + ':' if (UseCapturedNS_ and self.member_nsprefix_) else ''
            member_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='member', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'member':
            obj_ = memberRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.member.append(obj_)
            obj_.original_tagname_ = 'member'
# end class listofallmembersType


class memberRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, prot=None, virt=None, ambiguityscope=None, scope=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.prot = _cast(None, prot)
        self.prot_nsprefix_ = None
        self.virt = _cast(None, virt)
        self.virt_nsprefix_ = None
        self.ambiguityscope = _cast(None, ambiguityscope)
        self.ambiguityscope_nsprefix_ = None
        self.scope = scope
        self.scope_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, memberRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if memberRefType.subclass:
            return memberRefType.subclass(*args_, **kwargs_)
        else:
            return memberRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_prot(self):
        return self.prot
    def set_prot(self, prot):
        self.prot = prot
    def get_virt(self):
        return self.virt
    def set_virt(self, virt):
        self.virt = virt
    def get_ambiguityscope(self):
        return self.ambiguityscope
    def set_ambiguityscope(self, ambiguityscope):
        self.ambiguityscope = ambiguityscope
    def validate_DoxProtectionKind(self, value):
        # Validate type DoxProtectionKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['public', 'protected', 'private', 'package']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxProtectionKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxVirtualKind(self, value):
        # Validate type DoxVirtualKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['non-virtual', 'virtual', 'pure-virtual']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxVirtualKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.scope is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='memberRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memberRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'memberRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='memberRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='memberRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='memberRefType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.prot is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            outfile.write(' prot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prot), input_name='prot')), ))
        if self.virt is not None and 'virt' not in already_processed:
            already_processed.add('virt')
            outfile.write(' virt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.virt), input_name='virt')), ))
        if self.ambiguityscope is not None and 'ambiguityscope' not in already_processed:
            already_processed.add('ambiguityscope')
            outfile.write(' ambiguityscope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ambiguityscope), input_name='ambiguityscope')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='memberRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scope is not None:
            namespaceprefix_ = self.scope_nsprefix_ + ':' if (UseCapturedNS_ and self.scope_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscope>%s</%sscope>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.scope), input_name='scope')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('prot', node)
        if value is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            self.prot = value
            self.validate_DoxProtectionKind(self.prot)    # validate type DoxProtectionKind
        value = find_attr_value_('virt', node)
        if value is not None and 'virt' not in already_processed:
            already_processed.add('virt')
            self.virt = value
            self.validate_DoxVirtualKind(self.virt)    # validate type DoxVirtualKind
        value = find_attr_value_('ambiguityscope', node)
        if value is not None and 'ambiguityscope' not in already_processed:
            already_processed.add('ambiguityscope')
            self.ambiguityscope = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'scope':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'scope')
            value_ = self.gds_validate_string(value_, node, 'scope')
            self.scope = value_
            self.scope_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class memberRefType


class scope(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, scope)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if scope.subclass:
            return scope.subclass(*args_, **kwargs_)
        else:
            return scope(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scope', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scope')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'scope':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scope')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='scope', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scope'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='scope', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class scope


class name(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, name)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if name.subclass:
            return name.subclass(*args_, **kwargs_)
        else:
            return name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='name', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('name')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'name':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='name', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='name'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='name', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class name


class docHtmlOnlyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, block=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.block = _cast(None, block)
        self.block_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docHtmlOnlyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docHtmlOnlyType.subclass:
            return docHtmlOnlyType.subclass(*args_, **kwargs_)
        else:
            return docHtmlOnlyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_block(self):
        return self.block
    def set_block(self, block):
        self.block = block
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docHtmlOnlyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docHtmlOnlyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docHtmlOnlyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docHtmlOnlyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docHtmlOnlyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docHtmlOnlyType'):
        if self.block is not None and 'block' not in already_processed:
            already_processed.add('block')
            outfile.write(' block=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.block), input_name='block')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docHtmlOnlyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('block', node)
        if value is not None and 'block' not in already_processed:
            already_processed.add('block')
            self.block = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class docHtmlOnlyType


class compoundRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, prot=None, virt=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.prot = _cast(None, prot)
        self.prot_nsprefix_ = None
        self.virt = _cast(None, virt)
        self.virt_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, compoundRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if compoundRefType.subclass:
            return compoundRefType.subclass(*args_, **kwargs_)
        else:
            return compoundRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_prot(self):
        return self.prot
    def set_prot(self, prot):
        self.prot = prot
    def get_virt(self):
        return self.virt
    def set_virt(self, virt):
        self.virt = virt
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DoxProtectionKind(self, value):
        # Validate type DoxProtectionKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['public', 'protected', 'private', 'package']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxProtectionKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxVirtualKind(self, value):
        # Validate type DoxVirtualKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['non-virtual', 'virtual', 'pure-virtual']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxVirtualKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='compoundRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('compoundRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'compoundRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='compoundRefType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='compoundRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='compoundRefType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.prot is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            outfile.write(' prot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prot), input_name='prot')), ))
        if self.virt is not None and 'virt' not in already_processed:
            already_processed.add('virt')
            outfile.write(' virt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.virt), input_name='virt')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='compoundRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('prot', node)
        if value is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            self.prot = value
            self.validate_DoxProtectionKind(self.prot)    # validate type DoxProtectionKind
        value = find_attr_value_('virt', node)
        if value is not None and 'virt' not in already_processed:
            already_processed.add('virt')
            self.virt = value
            self.validate_DoxVirtualKind(self.virt)    # validate type DoxVirtualKind
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class compoundRefType


class reimplementType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reimplementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reimplementType.subclass:
            return reimplementType.subclass(*args_, **kwargs_)
        else:
            return reimplementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='reimplementType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('reimplementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'reimplementType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reimplementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='reimplementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='reimplementType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='reimplementType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class reimplementType


class incType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, local=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.local = _cast(None, local)
        self.local_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, incType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if incType.subclass:
            return incType.subclass(*args_, **kwargs_)
        else:
            return incType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_local(self):
        return self.local
    def set_local(self, local):
        self.local = local
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DoxBool(self, value):
        # Validate type DoxBool, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxBool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='incType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('incType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'incType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='incType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='incType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='incType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.local is not None and 'local' not in already_processed:
            already_processed.add('local')
            outfile.write(' local=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.local), input_name='local')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='incType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('local', node)
        if value is not None and 'local' not in already_processed:
            already_processed.add('local')
            self.local = value
            self.validate_DoxBool(self.local)    # validate type DoxBool
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class incType


class refType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, prot=None, inline=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.prot = _cast(None, prot)
        self.prot_nsprefix_ = None
        self.inline = _cast(None, inline)
        self.inline_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refType.subclass:
            return refType.subclass(*args_, **kwargs_)
        else:
            return refType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_prot(self):
        return self.prot
    def set_prot(self, prot):
        self.prot = prot
    def get_inline(self):
        return self.inline
    def set_inline(self, inline):
        self.inline = inline
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DoxProtectionKind(self, value):
        # Validate type DoxProtectionKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['public', 'protected', 'private', 'package']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxProtectionKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxBool(self, value):
        # Validate type DoxBool, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxBool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='refType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'refType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='refType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='refType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='refType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.prot is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            outfile.write(' prot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prot), input_name='prot')), ))
        if self.inline is not None and 'inline' not in already_processed:
            already_processed.add('inline')
            outfile.write(' inline=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inline), input_name='inline')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='refType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('prot', node)
        if value is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            self.prot = value
            self.validate_DoxProtectionKind(self.prot)    # validate type DoxProtectionKind
        value = find_attr_value_('inline', node)
        if value is not None and 'inline' not in already_processed:
            already_processed.add('inline')
            self.inline = value
            self.validate_DoxBool(self.inline)    # validate type DoxBool
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class refType


class refTextType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, kindref=None, external=None, tooltip=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.kindref = _cast(None, kindref)
        self.kindref_nsprefix_ = None
        self.external = _cast(None, external)
        self.external_nsprefix_ = None
        self.tooltip = _cast(None, tooltip)
        self.tooltip_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refTextType.subclass:
            return refTextType.subclass(*args_, **kwargs_)
        else:
            return refTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_kindref(self):
        return self.kindref
    def set_kindref(self, kindref):
        self.kindref = kindref
    def get_external(self):
        return self.external
    def set_external(self, external):
        self.external = external
    def get_tooltip(self):
        return self.tooltip
    def set_tooltip(self, tooltip):
        self.tooltip = tooltip
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DoxRefKind(self, value):
        # Validate type DoxRefKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['compound', 'member']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxRefKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='refTextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'refTextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='refTextType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='refTextType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='refTextType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.kindref is not None and 'kindref' not in already_processed:
            already_processed.add('kindref')
            outfile.write(' kindref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kindref), input_name='kindref')), ))
        if self.external is not None and 'external' not in already_processed:
            already_processed.add('external')
            outfile.write(' external=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.external), input_name='external')), ))
        if self.tooltip is not None and 'tooltip' not in already_processed:
            already_processed.add('tooltip')
            outfile.write(' tooltip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tooltip), input_name='tooltip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='refTextType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('kindref', node)
        if value is not None and 'kindref' not in already_processed:
            already_processed.add('kindref')
            self.kindref = value
            self.validate_DoxRefKind(self.kindref)    # validate type DoxRefKind
        value = find_attr_value_('external', node)
        if value is not None and 'external' not in already_processed:
            already_processed.add('external')
            self.external = value
        value = find_attr_value_('tooltip', node)
        if value is not None and 'tooltip' not in already_processed:
            already_processed.add('tooltip')
            self.tooltip = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class refTextType


class MemberType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, kind=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.kind = _cast(None, kind)
        self.kind_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemberType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemberType.subclass:
            return MemberType.subclass(*args_, **kwargs_)
        else:
            return MemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def validate_MemberKind(self, value):
        # Validate type MemberKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['define', 'property', 'event', 'variable', 'typedef', 'enum', 'enumvalue', 'function', 'signal', 'prototype', 'friend', 'dcop', 'slot']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on MemberKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MemberType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MemberType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MemberType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MemberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MemberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MemberType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MemberType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.validate_MemberKind(self.kind)    # validate type MemberKind
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
# end class MemberType


class sectiondefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, kind=None, header=None, description=None, memberdef=None, member=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.kind = _cast(None, kind)
        self.kind_nsprefix_ = None
        self.header = header
        self.header_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        if memberdef is None:
            self.memberdef = []
        else:
            self.memberdef = memberdef
        self.memberdef_nsprefix_ = None
        if member is None:
            self.member = []
        else:
            self.member = member
        self.member_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sectiondefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sectiondefType.subclass:
            return sectiondefType.subclass(*args_, **kwargs_)
        else:
            return sectiondefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_header(self):
        return self.header
    def set_header(self, header):
        self.header = header
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_memberdef(self):
        return self.memberdef
    def set_memberdef(self, memberdef):
        self.memberdef = memberdef
    def add_memberdef(self, value):
        self.memberdef.append(value)
    def insert_memberdef_at(self, index, value):
        self.memberdef.insert(index, value)
    def replace_memberdef_at(self, index, value):
        self.memberdef[index] = value
    def get_member(self):
        return self.member
    def set_member(self, member):
        self.member = member
    def add_member(self, value):
        self.member.append(value)
    def insert_member_at(self, index, value):
        self.member.insert(index, value)
    def replace_member_at(self, index, value):
        self.member[index] = value
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def validate_DoxSectionKind(self, value):
        # Validate type DoxSectionKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['user-defined', 'public-type', 'public-func', 'public-attrib', 'public-slot', 'signal', 'dcop-func', 'property', 'event', 'public-static-func', 'public-static-attrib', 'protected-type', 'protected-func', 'protected-attrib', 'protected-slot', 'protected-static-func', 'protected-static-attrib', 'package-type', 'package-func', 'package-attrib', 'package-static-func', 'package-static-attrib', 'private-type', 'private-func', 'private-attrib', 'private-slot', 'private-static-func', 'private-static-attrib', 'friend', 'related', 'define', 'prototype', 'typedef', 'enum', 'func', 'var']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxSectionKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.header is not None or
            self.description is not None or
            self.memberdef or
            self.member
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sectiondefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sectiondefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'sectiondefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sectiondefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sectiondefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sectiondefType'):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='sectiondefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.header is not None:
            namespaceprefix_ = self.header_nsprefix_ + ':' if (UseCapturedNS_ and self.header_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sheader>%s</%sheader>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.header), input_name='header')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            self.description.export(outfile, level, namespaceprefix_, namespacedef_='', name_='description', pretty_print=pretty_print)
        for memberdef_ in self.memberdef:
            namespaceprefix_ = self.memberdef_nsprefix_ + ':' if (UseCapturedNS_ and self.memberdef_nsprefix_) else ''
            memberdef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='memberdef', pretty_print=pretty_print)
        for member_ in self.member:
            namespaceprefix_ = self.member_nsprefix_ + ':' if (UseCapturedNS_ and self.member_nsprefix_) else ''
            member_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='member', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.validate_DoxSectionKind(self.kind)    # validate type DoxSectionKind
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'header':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'header')
            value_ = self.gds_validate_string(value_, node, 'header')
            self.header = value_
            self.header_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.description = obj_
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'memberdef':
            obj_ = memberdefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.memberdef.append(obj_)
            obj_.original_tagname_ = 'memberdef'
        elif nodeName_ == 'member':
            obj_ = MemberType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.member.append(obj_)
            obj_.original_tagname_ = 'member'
# end class sectiondefType


class memberdefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, kind=None, id=None, prot=None, static=None, strong=None, const=None, explicit=None, inline=None, refqual=None, virt=None, volatile=None, mutable=None, noexcept=None, constexpr=None, readable=None, writable=None, initonly=None, settable=None, privatesettable=None, protectedsettable=None, gettable=None, privategettable=None, protectedgettable=None, final=None, sealed=None, new=None, add=None, remove=None, raise_=None, optional=None, required=None, accessor=None, attribute=None, property=None, readonly=None, bound=None, removable=None, constrained=None, transient=None, maybevoid=None, maybedefault=None, maybeambiguous=None, templateparamlist=None, type_=None, definition=None, argsstring=None, name=None, qualifiedname=None, read=None, write=None, bitfield=None, reimplements=None, reimplementedby=None, qualifier=None, param=None, enumvalue=None, requiresclause=None, initializer=None, exceptions=None, briefdescription=None, detaileddescription=None, inbodydescription=None, location=None, references=None, referencedby=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.kind = _cast(None, kind)
        self.kind_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.prot = _cast(None, prot)
        self.prot_nsprefix_ = None
        self.static = _cast(None, static)
        self.static_nsprefix_ = None
        self.strong = _cast(None, strong)
        self.strong_nsprefix_ = None
        self.const = _cast(None, const)
        self.const_nsprefix_ = None
        self.explicit = _cast(None, explicit)
        self.explicit_nsprefix_ = None
        self.inline = _cast(None, inline)
        self.inline_nsprefix_ = None
        self.refqual = _cast(None, refqual)
        self.refqual_nsprefix_ = None
        self.virt = _cast(None, virt)
        self.virt_nsprefix_ = None
        self.volatile = _cast(None, volatile)
        self.volatile_nsprefix_ = None
        self.mutable = _cast(None, mutable)
        self.mutable_nsprefix_ = None
        self.noexcept = _cast(None, noexcept)
        self.noexcept_nsprefix_ = None
        self.constexpr = _cast(None, constexpr)
        self.constexpr_nsprefix_ = None
        self.readable = _cast(None, readable)
        self.readable_nsprefix_ = None
        self.writable = _cast(None, writable)
        self.writable_nsprefix_ = None
        self.initonly = _cast(None, initonly)
        self.initonly_nsprefix_ = None
        self.settable = _cast(None, settable)
        self.settable_nsprefix_ = None
        self.privatesettable = _cast(None, privatesettable)
        self.privatesettable_nsprefix_ = None
        self.protectedsettable = _cast(None, protectedsettable)
        self.protectedsettable_nsprefix_ = None
        self.gettable = _cast(None, gettable)
        self.gettable_nsprefix_ = None
        self.privategettable = _cast(None, privategettable)
        self.privategettable_nsprefix_ = None
        self.protectedgettable = _cast(None, protectedgettable)
        self.protectedgettable_nsprefix_ = None
        self.final = _cast(None, final)
        self.final_nsprefix_ = None
        self.sealed = _cast(None, sealed)
        self.sealed_nsprefix_ = None
        self.new = _cast(None, new)
        self.new_nsprefix_ = None
        self.add = _cast(None, add)
        self.add_nsprefix_ = None
        self.remove = _cast(None, remove)
        self.remove_nsprefix_ = None
        self.raise_ = _cast(None, raise_)
        self.raise__nsprefix_ = None
        self.optional = _cast(None, optional)
        self.optional_nsprefix_ = None
        self.required = _cast(None, required)
        self.required_nsprefix_ = None
        self.accessor = _cast(None, accessor)
        self.accessor_nsprefix_ = None
        self.attribute = _cast(None, attribute)
        self.attribute_nsprefix_ = None
        self.property = _cast(None, property)
        self.property_nsprefix_ = None
        self.readonly = _cast(None, readonly)
        self.readonly_nsprefix_ = None
        self.bound = _cast(None, bound)
        self.bound_nsprefix_ = None
        self.removable = _cast(None, removable)
        self.removable_nsprefix_ = None
        self.constrained = _cast(None, constrained)
        self.constrained_nsprefix_ = None
        self.transient = _cast(None, transient)
        self.transient_nsprefix_ = None
        self.maybevoid = _cast(None, maybevoid)
        self.maybevoid_nsprefix_ = None
        self.maybedefault = _cast(None, maybedefault)
        self.maybedefault_nsprefix_ = None
        self.maybeambiguous = _cast(None, maybeambiguous)
        self.maybeambiguous_nsprefix_ = None
        self.templateparamlist = templateparamlist
        self.templateparamlist_nsprefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
        self.definition = definition
        self.definition_nsprefix_ = None
        self.argsstring = argsstring
        self.argsstring_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.qualifiedname = qualifiedname
        self.qualifiedname_nsprefix_ = None
        self.read = read
        self.read_nsprefix_ = None
        self.write = write
        self.write_nsprefix_ = None
        self.bitfield = bitfield
        self.bitfield_nsprefix_ = None
        if reimplements is None:
            self.reimplements = []
        else:
            self.reimplements = reimplements
        self.reimplements_nsprefix_ = None
        if reimplementedby is None:
            self.reimplementedby = []
        else:
            self.reimplementedby = reimplementedby
        self.reimplementedby_nsprefix_ = None
        if qualifier is None:
            self.qualifier = []
        else:
            self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        if param is None:
            self.param = []
        else:
            self.param = param
        self.param_nsprefix_ = None
        if enumvalue is None:
            self.enumvalue = []
        else:
            self.enumvalue = enumvalue
        self.enumvalue_nsprefix_ = None
        self.requiresclause = requiresclause
        self.requiresclause_nsprefix_ = None
        self.initializer = initializer
        self.initializer_nsprefix_ = None
        self.exceptions = exceptions
        self.exceptions_nsprefix_ = None
        self.briefdescription = briefdescription
        self.briefdescription_nsprefix_ = None
        self.detaileddescription = detaileddescription
        self.detaileddescription_nsprefix_ = None
        self.inbodydescription = inbodydescription
        self.inbodydescription_nsprefix_ = None
        self.location = location
        self.location_nsprefix_ = None
        if references is None:
            self.references = []
        else:
            self.references = references
        self.references_nsprefix_ = None
        if referencedby is None:
            self.referencedby = []
        else:
            self.referencedby = referencedby
        self.referencedby_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, memberdefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if memberdefType.subclass:
            return memberdefType.subclass(*args_, **kwargs_)
        else:
            return memberdefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_templateparamlist(self):
        return self.templateparamlist
    def set_templateparamlist(self, templateparamlist):
        self.templateparamlist = templateparamlist
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_definition(self):
        return self.definition
    def set_definition(self, definition):
        self.definition = definition
    def get_argsstring(self):
        return self.argsstring
    def set_argsstring(self, argsstring):
        self.argsstring = argsstring
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_qualifiedname(self):
        return self.qualifiedname
    def set_qualifiedname(self, qualifiedname):
        self.qualifiedname = qualifiedname
    def get_read(self):
        return self.read
    def set_read(self, read):
        self.read = read
    def get_write(self):
        return self.write
    def set_write(self, write):
        self.write = write
    def get_bitfield(self):
        return self.bitfield
    def set_bitfield(self, bitfield):
        self.bitfield = bitfield
    def get_reimplements(self):
        return self.reimplements
    def set_reimplements(self, reimplements):
        self.reimplements = reimplements
    def add_reimplements(self, value):
        self.reimplements.append(value)
    def insert_reimplements_at(self, index, value):
        self.reimplements.insert(index, value)
    def replace_reimplements_at(self, index, value):
        self.reimplements[index] = value
    def get_reimplementedby(self):
        return self.reimplementedby
    def set_reimplementedby(self, reimplementedby):
        self.reimplementedby = reimplementedby
    def add_reimplementedby(self, value):
        self.reimplementedby.append(value)
    def insert_reimplementedby_at(self, index, value):
        self.reimplementedby.insert(index, value)
    def replace_reimplementedby_at(self, index, value):
        self.reimplementedby[index] = value
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def add_qualifier(self, value):
        self.qualifier.append(value)
    def insert_qualifier_at(self, index, value):
        self.qualifier.insert(index, value)
    def replace_qualifier_at(self, index, value):
        self.qualifier[index] = value
    def get_param(self):
        return self.param
    def set_param(self, param):
        self.param = param
    def add_param(self, value):
        self.param.append(value)
    def insert_param_at(self, index, value):
        self.param.insert(index, value)
    def replace_param_at(self, index, value):
        self.param[index] = value
    def get_enumvalue(self):
        return self.enumvalue
    def set_enumvalue(self, enumvalue):
        self.enumvalue = enumvalue
    def add_enumvalue(self, value):
        self.enumvalue.append(value)
    def insert_enumvalue_at(self, index, value):
        self.enumvalue.insert(index, value)
    def replace_enumvalue_at(self, index, value):
        self.enumvalue[index] = value
    def get_requiresclause(self):
        return self.requiresclause
    def set_requiresclause(self, requiresclause):
        self.requiresclause = requiresclause
    def get_initializer(self):
        return self.initializer
    def set_initializer(self, initializer):
        self.initializer = initializer
    def get_exceptions(self):
        return self.exceptions
    def set_exceptions(self, exceptions):
        self.exceptions = exceptions
    def get_briefdescription(self):
        return self.briefdescription
    def set_briefdescription(self, briefdescription):
        self.briefdescription = briefdescription
    def get_detaileddescription(self):
        return self.detaileddescription
    def set_detaileddescription(self, detaileddescription):
        self.detaileddescription = detaileddescription
    def get_inbodydescription(self):
        return self.inbodydescription
    def set_inbodydescription(self, inbodydescription):
        self.inbodydescription = inbodydescription
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_references(self):
        return self.references
    def set_references(self, references):
        self.references = references
    def add_references(self, value):
        self.references.append(value)
    def insert_references_at(self, index, value):
        self.references.insert(index, value)
    def replace_references_at(self, index, value):
        self.references[index] = value
    def get_referencedby(self):
        return self.referencedby
    def set_referencedby(self, referencedby):
        self.referencedby = referencedby
    def add_referencedby(self, value):
        self.referencedby.append(value)
    def insert_referencedby_at(self, index, value):
        self.referencedby.insert(index, value)
    def replace_referencedby_at(self, index, value):
        self.referencedby[index] = value
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_prot(self):
        return self.prot
    def set_prot(self, prot):
        self.prot = prot
    def get_static(self):
        return self.static
    def set_static(self, static):
        self.static = static
    def get_strong(self):
        return self.strong
    def set_strong(self, strong):
        self.strong = strong
    def get_const(self):
        return self.const
    def set_const(self, const):
        self.const = const
    def get_explicit(self):
        return self.explicit
    def set_explicit(self, explicit):
        self.explicit = explicit
    def get_inline(self):
        return self.inline
    def set_inline(self, inline):
        self.inline = inline
    def get_refqual(self):
        return self.refqual
    def set_refqual(self, refqual):
        self.refqual = refqual
    def get_virt(self):
        return self.virt
    def set_virt(self, virt):
        self.virt = virt
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_mutable(self):
        return self.mutable
    def set_mutable(self, mutable):
        self.mutable = mutable
    def get_noexcept(self):
        return self.noexcept
    def set_noexcept(self, noexcept):
        self.noexcept = noexcept
    def get_constexpr(self):
        return self.constexpr
    def set_constexpr(self, constexpr):
        self.constexpr = constexpr
    def get_readable(self):
        return self.readable
    def set_readable(self, readable):
        self.readable = readable
    def get_writable(self):
        return self.writable
    def set_writable(self, writable):
        self.writable = writable
    def get_initonly(self):
        return self.initonly
    def set_initonly(self, initonly):
        self.initonly = initonly
    def get_settable(self):
        return self.settable
    def set_settable(self, settable):
        self.settable = settable
    def get_privatesettable(self):
        return self.privatesettable
    def set_privatesettable(self, privatesettable):
        self.privatesettable = privatesettable
    def get_protectedsettable(self):
        return self.protectedsettable
    def set_protectedsettable(self, protectedsettable):
        self.protectedsettable = protectedsettable
    def get_gettable(self):
        return self.gettable
    def set_gettable(self, gettable):
        self.gettable = gettable
    def get_privategettable(self):
        return self.privategettable
    def set_privategettable(self, privategettable):
        self.privategettable = privategettable
    def get_protectedgettable(self):
        return self.protectedgettable
    def set_protectedgettable(self, protectedgettable):
        self.protectedgettable = protectedgettable
    def get_final(self):
        return self.final
    def set_final(self, final):
        self.final = final
    def get_sealed(self):
        return self.sealed
    def set_sealed(self, sealed):
        self.sealed = sealed
    def get_new(self):
        return self.new
    def set_new(self, new):
        self.new = new
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def get_raise(self):
        return self.raise_
    def set_raise(self, raise_):
        self.raise_ = raise_
    def get_optional(self):
        return self.optional
    def set_optional(self, optional):
        self.optional = optional
    def get_required(self):
        return self.required
    def set_required(self, required):
        self.required = required
    def get_accessor(self):
        return self.accessor
    def set_accessor(self, accessor):
        self.accessor = accessor
    def get_attribute(self):
        return self.attribute
    def set_attribute(self, attribute):
        self.attribute = attribute
    def get_property(self):
        return self.property
    def set_property(self, property):
        self.property = property
    def get_readonly(self):
        return self.readonly
    def set_readonly(self, readonly):
        self.readonly = readonly
    def get_bound(self):
        return self.bound
    def set_bound(self, bound):
        self.bound = bound
    def get_removable(self):
        return self.removable
    def set_removable(self, removable):
        self.removable = removable
    def get_constrained(self):
        return self.constrained
    def set_constrained(self, constrained):
        self.constrained = constrained
    def get_transient(self):
        return self.transient
    def set_transient(self, transient):
        self.transient = transient
    def get_maybevoid(self):
        return self.maybevoid
    def set_maybevoid(self, maybevoid):
        self.maybevoid = maybevoid
    def get_maybedefault(self):
        return self.maybedefault
    def set_maybedefault(self, maybedefault):
        self.maybedefault = maybedefault
    def get_maybeambiguous(self):
        return self.maybeambiguous
    def set_maybeambiguous(self, maybeambiguous):
        self.maybeambiguous = maybeambiguous
    def validate_DoxMemberKind(self, value):
        # Validate type DoxMemberKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['define', 'property', 'event', 'variable', 'typedef', 'enum', 'function', 'signal', 'prototype', 'friend', 'dcop', 'slot', 'interface', 'service']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxMemberKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxProtectionKind(self, value):
        # Validate type DoxProtectionKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['public', 'protected', 'private', 'package']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxProtectionKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxBool(self, value):
        # Validate type DoxBool, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxBool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxRefQualifierKind(self, value):
        # Validate type DoxRefQualifierKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['lvalue', 'rvalue']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxRefQualifierKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxVirtualKind(self, value):
        # Validate type DoxVirtualKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['non-virtual', 'virtual', 'pure-virtual']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxVirtualKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxAccessor(self, value):
        # Validate type DoxAccessor, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['retain', 'copy', 'assign', 'weak', 'strong', 'unretained']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxAccessor' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.templateparamlist is not None or
            self.type_ is not None or
            self.definition is not None or
            self.argsstring is not None or
            self.name is not None or
            self.qualifiedname is not None or
            self.read is not None or
            self.write is not None or
            self.bitfield is not None or
            self.reimplements or
            self.reimplementedby or
            self.qualifier or
            self.param or
            self.enumvalue or
            self.requiresclause is not None or
            self.initializer is not None or
            self.exceptions is not None or
            self.briefdescription is not None or
            self.detaileddescription is not None or
            self.inbodydescription is not None or
            self.location is not None or
            self.references or
            self.referencedby
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='memberdefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memberdefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'memberdefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='memberdefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='memberdefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='memberdefType'):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.prot is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            outfile.write(' prot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prot), input_name='prot')), ))
        if self.static is not None and 'static' not in already_processed:
            already_processed.add('static')
            outfile.write(' static=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.static), input_name='static')), ))
        if self.strong is not None and 'strong' not in already_processed:
            already_processed.add('strong')
            outfile.write(' strong=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.strong), input_name='strong')), ))
        if self.const is not None and 'const' not in already_processed:
            already_processed.add('const')
            outfile.write(' const=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.const), input_name='const')), ))
        if self.explicit is not None and 'explicit' not in already_processed:
            already_processed.add('explicit')
            outfile.write(' explicit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.explicit), input_name='explicit')), ))
        if self.inline is not None and 'inline' not in already_processed:
            already_processed.add('inline')
            outfile.write(' inline=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inline), input_name='inline')), ))
        if self.refqual is not None and 'refqual' not in already_processed:
            already_processed.add('refqual')
            outfile.write(' refqual=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refqual), input_name='refqual')), ))
        if self.virt is not None and 'virt' not in already_processed:
            already_processed.add('virt')
            outfile.write(' virt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.virt), input_name='virt')), ))
        if self.volatile is not None and 'volatile' not in already_processed:
            already_processed.add('volatile')
            outfile.write(' volatile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.volatile), input_name='volatile')), ))
        if self.mutable is not None and 'mutable' not in already_processed:
            already_processed.add('mutable')
            outfile.write(' mutable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mutable), input_name='mutable')), ))
        if self.noexcept is not None and 'noexcept' not in already_processed:
            already_processed.add('noexcept')
            outfile.write(' noexcept=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.noexcept), input_name='noexcept')), ))
        if self.constexpr is not None and 'constexpr' not in already_processed:
            already_processed.add('constexpr')
            outfile.write(' constexpr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.constexpr), input_name='constexpr')), ))
        if self.readable is not None and 'readable' not in already_processed:
            already_processed.add('readable')
            outfile.write(' readable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.readable), input_name='readable')), ))
        if self.writable is not None and 'writable' not in already_processed:
            already_processed.add('writable')
            outfile.write(' writable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.writable), input_name='writable')), ))
        if self.initonly is not None and 'initonly' not in already_processed:
            already_processed.add('initonly')
            outfile.write(' initonly=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.initonly), input_name='initonly')), ))
        if self.settable is not None and 'settable' not in already_processed:
            already_processed.add('settable')
            outfile.write(' settable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.settable), input_name='settable')), ))
        if self.privatesettable is not None and 'privatesettable' not in already_processed:
            already_processed.add('privatesettable')
            outfile.write(' privatesettable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.privatesettable), input_name='privatesettable')), ))
        if self.protectedsettable is not None and 'protectedsettable' not in already_processed:
            already_processed.add('protectedsettable')
            outfile.write(' protectedsettable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.protectedsettable), input_name='protectedsettable')), ))
        if self.gettable is not None and 'gettable' not in already_processed:
            already_processed.add('gettable')
            outfile.write(' gettable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gettable), input_name='gettable')), ))
        if self.privategettable is not None and 'privategettable' not in already_processed:
            already_processed.add('privategettable')
            outfile.write(' privategettable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.privategettable), input_name='privategettable')), ))
        if self.protectedgettable is not None and 'protectedgettable' not in already_processed:
            already_processed.add('protectedgettable')
            outfile.write(' protectedgettable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.protectedgettable), input_name='protectedgettable')), ))
        if self.final is not None and 'final' not in already_processed:
            already_processed.add('final')
            outfile.write(' final=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.final), input_name='final')), ))
        if self.sealed is not None and 'sealed' not in already_processed:
            already_processed.add('sealed')
            outfile.write(' sealed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sealed), input_name='sealed')), ))
        if self.new is not None and 'new' not in already_processed:
            already_processed.add('new')
            outfile.write(' new=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.new), input_name='new')), ))
        if self.add is not None and 'add' not in already_processed:
            already_processed.add('add')
            outfile.write(' add=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.add), input_name='add')), ))
        if self.remove is not None and 'remove' not in already_processed:
            already_processed.add('remove')
            outfile.write(' remove=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.remove), input_name='remove')), ))
        if self.raise_ is not None and 'raise_' not in already_processed:
            already_processed.add('raise_')
            outfile.write(' raise=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.raise_), input_name='raise')), ))
        if self.optional is not None and 'optional' not in already_processed:
            already_processed.add('optional')
            outfile.write(' optional=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.optional), input_name='optional')), ))
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.required), input_name='required')), ))
        if self.accessor is not None and 'accessor' not in already_processed:
            already_processed.add('accessor')
            outfile.write(' accessor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accessor), input_name='accessor')), ))
        if self.attribute is not None and 'attribute' not in already_processed:
            already_processed.add('attribute')
            outfile.write(' attribute=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.attribute), input_name='attribute')), ))
        if self.property is not None and 'property' not in already_processed:
            already_processed.add('property')
            outfile.write(' property=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.property), input_name='property')), ))
        if self.readonly is not None and 'readonly' not in already_processed:
            already_processed.add('readonly')
            outfile.write(' readonly=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.readonly), input_name='readonly')), ))
        if self.bound is not None and 'bound' not in already_processed:
            already_processed.add('bound')
            outfile.write(' bound=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bound), input_name='bound')), ))
        if self.removable is not None and 'removable' not in already_processed:
            already_processed.add('removable')
            outfile.write(' removable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.removable), input_name='removable')), ))
        if self.constrained is not None and 'constrained' not in already_processed:
            already_processed.add('constrained')
            outfile.write(' constrained=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.constrained), input_name='constrained')), ))
        if self.transient is not None and 'transient' not in already_processed:
            already_processed.add('transient')
            outfile.write(' transient=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.transient), input_name='transient')), ))
        if self.maybevoid is not None and 'maybevoid' not in already_processed:
            already_processed.add('maybevoid')
            outfile.write(' maybevoid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.maybevoid), input_name='maybevoid')), ))
        if self.maybedefault is not None and 'maybedefault' not in already_processed:
            already_processed.add('maybedefault')
            outfile.write(' maybedefault=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.maybedefault), input_name='maybedefault')), ))
        if self.maybeambiguous is not None and 'maybeambiguous' not in already_processed:
            already_processed.add('maybeambiguous')
            outfile.write(' maybeambiguous=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.maybeambiguous), input_name='maybeambiguous')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='memberdefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.templateparamlist is not None:
            namespaceprefix_ = self.templateparamlist_nsprefix_ + ':' if (UseCapturedNS_ and self.templateparamlist_nsprefix_) else ''
            self.templateparamlist.export(outfile, level, namespaceprefix_, namespacedef_='', name_='templateparamlist', pretty_print=pretty_print)
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        if self.definition is not None:
            namespaceprefix_ = self.definition_nsprefix_ + ':' if (UseCapturedNS_ and self.definition_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefinition>%s</%sdefinition>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.definition), input_name='definition')), namespaceprefix_ , eol_))
        if self.argsstring is not None:
            namespaceprefix_ = self.argsstring_nsprefix_ + ':' if (UseCapturedNS_ and self.argsstring_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sargsstring>%s</%sargsstring>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.argsstring), input_name='argsstring')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.qualifiedname is not None:
            namespaceprefix_ = self.qualifiedname_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifiedname_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squalifiedname>%s</%squalifiedname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qualifiedname), input_name='qualifiedname')), namespaceprefix_ , eol_))
        if self.read is not None:
            namespaceprefix_ = self.read_nsprefix_ + ':' if (UseCapturedNS_ and self.read_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sread>%s</%sread>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.read), input_name='read')), namespaceprefix_ , eol_))
        if self.write is not None:
            namespaceprefix_ = self.write_nsprefix_ + ':' if (UseCapturedNS_ and self.write_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swrite>%s</%swrite>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.write), input_name='write')), namespaceprefix_ , eol_))
        if self.bitfield is not None:
            namespaceprefix_ = self.bitfield_nsprefix_ + ':' if (UseCapturedNS_ and self.bitfield_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbitfield>%s</%sbitfield>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.bitfield), input_name='bitfield')), namespaceprefix_ , eol_))
        for reimplements_ in self.reimplements:
            namespaceprefix_ = self.reimplements_nsprefix_ + ':' if (UseCapturedNS_ and self.reimplements_nsprefix_) else ''
            reimplements_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reimplements', pretty_print=pretty_print)
        for reimplementedby_ in self.reimplementedby:
            namespaceprefix_ = self.reimplementedby_nsprefix_ + ':' if (UseCapturedNS_ and self.reimplementedby_nsprefix_) else ''
            reimplementedby_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reimplementedby', pretty_print=pretty_print)
        for qualifier_ in self.qualifier:
            namespaceprefix_ = self.qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squalifier>%s</%squalifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(qualifier_), input_name='qualifier')), namespaceprefix_ , eol_))
        for param_ in self.param:
            namespaceprefix_ = self.param_nsprefix_ + ':' if (UseCapturedNS_ and self.param_nsprefix_) else ''
            param_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='param', pretty_print=pretty_print)
        for enumvalue_ in self.enumvalue:
            namespaceprefix_ = self.enumvalue_nsprefix_ + ':' if (UseCapturedNS_ and self.enumvalue_nsprefix_) else ''
            enumvalue_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enumvalue', pretty_print=pretty_print)
        if self.requiresclause is not None:
            namespaceprefix_ = self.requiresclause_nsprefix_ + ':' if (UseCapturedNS_ and self.requiresclause_nsprefix_) else ''
            self.requiresclause.export(outfile, level, namespaceprefix_, namespacedef_='', name_='requiresclause', pretty_print=pretty_print)
        if self.initializer is not None:
            namespaceprefix_ = self.initializer_nsprefix_ + ':' if (UseCapturedNS_ and self.initializer_nsprefix_) else ''
            self.initializer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='initializer', pretty_print=pretty_print)
        if self.exceptions is not None:
            namespaceprefix_ = self.exceptions_nsprefix_ + ':' if (UseCapturedNS_ and self.exceptions_nsprefix_) else ''
            self.exceptions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='exceptions', pretty_print=pretty_print)
        if self.briefdescription is not None:
            namespaceprefix_ = self.briefdescription_nsprefix_ + ':' if (UseCapturedNS_ and self.briefdescription_nsprefix_) else ''
            self.briefdescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='briefdescription', pretty_print=pretty_print)
        if self.detaileddescription is not None:
            namespaceprefix_ = self.detaileddescription_nsprefix_ + ':' if (UseCapturedNS_ and self.detaileddescription_nsprefix_) else ''
            self.detaileddescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detaileddescription', pretty_print=pretty_print)
        if self.inbodydescription is not None:
            namespaceprefix_ = self.inbodydescription_nsprefix_ + ':' if (UseCapturedNS_ and self.inbodydescription_nsprefix_) else ''
            self.inbodydescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inbodydescription', pretty_print=pretty_print)
        if self.location is not None:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            self.location.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
        for references_ in self.references:
            namespaceprefix_ = self.references_nsprefix_ + ':' if (UseCapturedNS_ and self.references_nsprefix_) else ''
            references_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='references', pretty_print=pretty_print)
        for referencedby_ in self.referencedby:
            namespaceprefix_ = self.referencedby_nsprefix_ + ':' if (UseCapturedNS_ and self.referencedby_nsprefix_) else ''
            referencedby_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='referencedby', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.validate_DoxMemberKind(self.kind)    # validate type DoxMemberKind
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('prot', node)
        if value is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            self.prot = value
            self.validate_DoxProtectionKind(self.prot)    # validate type DoxProtectionKind
        value = find_attr_value_('static', node)
        if value is not None and 'static' not in already_processed:
            already_processed.add('static')
            self.static = value
            self.validate_DoxBool(self.static)    # validate type DoxBool
        value = find_attr_value_('strong', node)
        if value is not None and 'strong' not in already_processed:
            already_processed.add('strong')
            self.strong = value
            self.validate_DoxBool(self.strong)    # validate type DoxBool
        value = find_attr_value_('const', node)
        if value is not None and 'const' not in already_processed:
            already_processed.add('const')
            self.const = value
            self.validate_DoxBool(self.const)    # validate type DoxBool
        value = find_attr_value_('explicit', node)
        if value is not None and 'explicit' not in already_processed:
            already_processed.add('explicit')
            self.explicit = value
            self.validate_DoxBool(self.explicit)    # validate type DoxBool
        value = find_attr_value_('inline', node)
        if value is not None and 'inline' not in already_processed:
            already_processed.add('inline')
            self.inline = value
            self.validate_DoxBool(self.inline)    # validate type DoxBool
        value = find_attr_value_('refqual', node)
        if value is not None and 'refqual' not in already_processed:
            already_processed.add('refqual')
            self.refqual = value
            self.validate_DoxRefQualifierKind(self.refqual)    # validate type DoxRefQualifierKind
        value = find_attr_value_('virt', node)
        if value is not None and 'virt' not in already_processed:
            already_processed.add('virt')
            self.virt = value
            self.validate_DoxVirtualKind(self.virt)    # validate type DoxVirtualKind
        value = find_attr_value_('volatile', node)
        if value is not None and 'volatile' not in already_processed:
            already_processed.add('volatile')
            self.volatile = value
            self.validate_DoxBool(self.volatile)    # validate type DoxBool
        value = find_attr_value_('mutable', node)
        if value is not None and 'mutable' not in already_processed:
            already_processed.add('mutable')
            self.mutable = value
            self.validate_DoxBool(self.mutable)    # validate type DoxBool
        value = find_attr_value_('noexcept', node)
        if value is not None and 'noexcept' not in already_processed:
            already_processed.add('noexcept')
            self.noexcept = value
            self.validate_DoxBool(self.noexcept)    # validate type DoxBool
        value = find_attr_value_('constexpr', node)
        if value is not None and 'constexpr' not in already_processed:
            already_processed.add('constexpr')
            self.constexpr = value
            self.validate_DoxBool(self.constexpr)    # validate type DoxBool
        value = find_attr_value_('readable', node)
        if value is not None and 'readable' not in already_processed:
            already_processed.add('readable')
            self.readable = value
            self.validate_DoxBool(self.readable)    # validate type DoxBool
        value = find_attr_value_('writable', node)
        if value is not None and 'writable' not in already_processed:
            already_processed.add('writable')
            self.writable = value
            self.validate_DoxBool(self.writable)    # validate type DoxBool
        value = find_attr_value_('initonly', node)
        if value is not None and 'initonly' not in already_processed:
            already_processed.add('initonly')
            self.initonly = value
            self.validate_DoxBool(self.initonly)    # validate type DoxBool
        value = find_attr_value_('settable', node)
        if value is not None and 'settable' not in already_processed:
            already_processed.add('settable')
            self.settable = value
            self.validate_DoxBool(self.settable)    # validate type DoxBool
        value = find_attr_value_('privatesettable', node)
        if value is not None and 'privatesettable' not in already_processed:
            already_processed.add('privatesettable')
            self.privatesettable = value
            self.validate_DoxBool(self.privatesettable)    # validate type DoxBool
        value = find_attr_value_('protectedsettable', node)
        if value is not None and 'protectedsettable' not in already_processed:
            already_processed.add('protectedsettable')
            self.protectedsettable = value
            self.validate_DoxBool(self.protectedsettable)    # validate type DoxBool
        value = find_attr_value_('gettable', node)
        if value is not None and 'gettable' not in already_processed:
            already_processed.add('gettable')
            self.gettable = value
            self.validate_DoxBool(self.gettable)    # validate type DoxBool
        value = find_attr_value_('privategettable', node)
        if value is not None and 'privategettable' not in already_processed:
            already_processed.add('privategettable')
            self.privategettable = value
            self.validate_DoxBool(self.privategettable)    # validate type DoxBool
        value = find_attr_value_('protectedgettable', node)
        if value is not None and 'protectedgettable' not in already_processed:
            already_processed.add('protectedgettable')
            self.protectedgettable = value
            self.validate_DoxBool(self.protectedgettable)    # validate type DoxBool
        value = find_attr_value_('final', node)
        if value is not None and 'final' not in already_processed:
            already_processed.add('final')
            self.final = value
            self.validate_DoxBool(self.final)    # validate type DoxBool
        value = find_attr_value_('sealed', node)
        if value is not None and 'sealed' not in already_processed:
            already_processed.add('sealed')
            self.sealed = value
            self.validate_DoxBool(self.sealed)    # validate type DoxBool
        value = find_attr_value_('new', node)
        if value is not None and 'new' not in already_processed:
            already_processed.add('new')
            self.new = value
            self.validate_DoxBool(self.new)    # validate type DoxBool
        value = find_attr_value_('add', node)
        if value is not None and 'add' not in already_processed:
            already_processed.add('add')
            self.add = value
            self.validate_DoxBool(self.add)    # validate type DoxBool
        value = find_attr_value_('remove', node)
        if value is not None and 'remove' not in already_processed:
            already_processed.add('remove')
            self.remove = value
            self.validate_DoxBool(self.remove)    # validate type DoxBool
        value = find_attr_value_('raise', node)
        if value is not None and 'raise' not in already_processed:
            already_processed.add('raise')
            self.raise_ = value
            self.validate_DoxBool(self.raise_)    # validate type DoxBool
        value = find_attr_value_('optional', node)
        if value is not None and 'optional' not in already_processed:
            already_processed.add('optional')
            self.optional = value
            self.validate_DoxBool(self.optional)    # validate type DoxBool
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            self.required = value
            self.validate_DoxBool(self.required)    # validate type DoxBool
        value = find_attr_value_('accessor', node)
        if value is not None and 'accessor' not in already_processed:
            already_processed.add('accessor')
            self.accessor = value
            self.validate_DoxAccessor(self.accessor)    # validate type DoxAccessor
        value = find_attr_value_('attribute', node)
        if value is not None and 'attribute' not in already_processed:
            already_processed.add('attribute')
            self.attribute = value
            self.validate_DoxBool(self.attribute)    # validate type DoxBool
        value = find_attr_value_('property', node)
        if value is not None and 'property' not in already_processed:
            already_processed.add('property')
            self.property = value
            self.validate_DoxBool(self.property)    # validate type DoxBool
        value = find_attr_value_('readonly', node)
        if value is not None and 'readonly' not in already_processed:
            already_processed.add('readonly')
            self.readonly = value
            self.validate_DoxBool(self.readonly)    # validate type DoxBool
        value = find_attr_value_('bound', node)
        if value is not None and 'bound' not in already_processed:
            already_processed.add('bound')
            self.bound = value
            self.validate_DoxBool(self.bound)    # validate type DoxBool
        value = find_attr_value_('removable', node)
        if value is not None and 'removable' not in already_processed:
            already_processed.add('removable')
            self.removable = value
            self.validate_DoxBool(self.removable)    # validate type DoxBool
        value = find_attr_value_('constrained', node)
        if value is not None and 'constrained' not in already_processed:
            already_processed.add('constrained')
            self.constrained = value
            self.validate_DoxBool(self.constrained)    # validate type DoxBool
        value = find_attr_value_('transient', node)
        if value is not None and 'transient' not in already_processed:
            already_processed.add('transient')
            self.transient = value
            self.validate_DoxBool(self.transient)    # validate type DoxBool
        value = find_attr_value_('maybevoid', node)
        if value is not None and 'maybevoid' not in already_processed:
            already_processed.add('maybevoid')
            self.maybevoid = value
            self.validate_DoxBool(self.maybevoid)    # validate type DoxBool
        value = find_attr_value_('maybedefault', node)
        if value is not None and 'maybedefault' not in already_processed:
            already_processed.add('maybedefault')
            self.maybedefault = value
            self.validate_DoxBool(self.maybedefault)    # validate type DoxBool
        value = find_attr_value_('maybeambiguous', node)
        if value is not None and 'maybeambiguous' not in already_processed:
            already_processed.add('maybeambiguous')
            self.maybeambiguous = value
            self.validate_DoxBool(self.maybeambiguous)    # validate type DoxBool
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'templateparamlist':
            obj_ = templateparamlistType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.templateparamlist = obj_
            obj_.original_tagname_ = 'templateparamlist'
        elif nodeName_ == 'type':
            obj_ = linkedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'definition':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'definition')
            value_ = self.gds_validate_string(value_, node, 'definition')
            self.definition = value_
            self.definition_nsprefix_ = child_.prefix
        elif nodeName_ == 'argsstring':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'argsstring')
            value_ = self.gds_validate_string(value_, node, 'argsstring')
            self.argsstring = value_
            self.argsstring_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'qualifiedname':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qualifiedname')
            value_ = self.gds_validate_string(value_, node, 'qualifiedname')
            self.qualifiedname = value_
            self.qualifiedname_nsprefix_ = child_.prefix
        elif nodeName_ == 'read':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'read')
            value_ = self.gds_validate_string(value_, node, 'read')
            self.read = value_
            self.read_nsprefix_ = child_.prefix
        elif nodeName_ == 'write':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'write')
            value_ = self.gds_validate_string(value_, node, 'write')
            self.write = value_
            self.write_nsprefix_ = child_.prefix
        elif nodeName_ == 'bitfield':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'bitfield')
            value_ = self.gds_validate_string(value_, node, 'bitfield')
            self.bitfield = value_
            self.bitfield_nsprefix_ = child_.prefix
        elif nodeName_ == 'reimplements':
            obj_ = reimplementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reimplements.append(obj_)
            obj_.original_tagname_ = 'reimplements'
        elif nodeName_ == 'reimplementedby':
            obj_ = reimplementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reimplementedby.append(obj_)
            obj_.original_tagname_ = 'reimplementedby'
        elif nodeName_ == 'qualifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qualifier')
            value_ = self.gds_validate_string(value_, node, 'qualifier')
            self.qualifier.append(value_)
            self.qualifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'param':
            obj_ = paramType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
        elif nodeName_ == 'enumvalue':
            obj_ = enumvalueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enumvalue.append(obj_)
            obj_.original_tagname_ = 'enumvalue'
        elif nodeName_ == 'requiresclause':
            obj_ = linkedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.requiresclause = obj_
            obj_.original_tagname_ = 'requiresclause'
        elif nodeName_ == 'initializer':
            obj_ = linkedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.initializer = obj_
            obj_.original_tagname_ = 'initializer'
        elif nodeName_ == 'exceptions':
            obj_ = linkedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exceptions = obj_
            obj_.original_tagname_ = 'exceptions'
        elif nodeName_ == 'briefdescription':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.briefdescription = obj_
            obj_.original_tagname_ = 'briefdescription'
        elif nodeName_ == 'detaileddescription':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.detaileddescription = obj_
            obj_.original_tagname_ = 'detaileddescription'
        elif nodeName_ == 'inbodydescription':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inbodydescription = obj_
            obj_.original_tagname_ = 'inbodydescription'
        elif nodeName_ == 'location':
            obj_ = locationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'references':
            obj_ = referenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.references.append(obj_)
            obj_.original_tagname_ = 'references'
        elif nodeName_ == 'referencedby':
            obj_ = referenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.referencedby.append(obj_)
            obj_.original_tagname_ = 'referencedby'
# end class memberdefType


class definition(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, definition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if definition.subclass:
            return definition.subclass(*args_, **kwargs_)
        else:
            return definition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='definition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('definition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'definition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='definition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='definition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='definition'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='definition', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class definition


class argsstring(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, argsstring)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if argsstring.subclass:
            return argsstring.subclass(*args_, **kwargs_)
        else:
            return argsstring(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='argsstring', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('argsstring')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'argsstring':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='argsstring')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='argsstring', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='argsstring'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='argsstring', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class argsstring


class qualifiedname(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qualifiedname)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qualifiedname.subclass:
            return qualifiedname.subclass(*args_, **kwargs_)
        else:
            return qualifiedname(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='qualifiedname', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qualifiedname')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'qualifiedname':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='qualifiedname')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='qualifiedname', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='qualifiedname'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='qualifiedname', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class qualifiedname


class read(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, read)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if read.subclass:
            return read.subclass(*args_, **kwargs_)
        else:
            return read(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='read', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('read')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'read':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='read')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='read', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='read'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='read', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class read


class write(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, write)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if write.subclass:
            return write.subclass(*args_, **kwargs_)
        else:
            return write(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='write', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('write')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'write':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='write')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='write', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='write'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='write', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class write


class bitfield(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bitfield)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bitfield.subclass:
            return bitfield.subclass(*args_, **kwargs_)
        else:
            return bitfield(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bitfield', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bitfield')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bitfield':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bitfield')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bitfield', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bitfield'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='bitfield', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class bitfield


class descriptionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, title=None, para=None, internal=None, sect1=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if internal is None:
            self.internal = []
        else:
            self.internal = internal
        self.internal_nsprefix_ = None
        if sect1 is None:
            self.sect1 = []
        else:
            self.sect1 = sect1
        self.sect1_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, descriptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if descriptionType.subclass:
            return descriptionType.subclass(*args_, **kwargs_)
        else:
            return descriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_internal(self):
        return self.internal
    def set_internal(self, internal):
        self.internal = internal
    def add_internal(self, value):
        self.internal.append(value)
    def insert_internal_at(self, index, value):
        self.internal.insert(index, value)
    def replace_internal_at(self, index, value):
        self.internal[index] = value
    def get_sect1(self):
        return self.sect1
    def set_sect1(self, sect1):
        self.sect1 = sect1
    def add_sect1(self, value):
        self.sect1.append(value)
    def insert_sect1_at(self, index, value):
        self.sect1.insert(index, value)
    def replace_sect1_at(self, index, value):
        self.sect1[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.title is not None or
            self.para or
            self.internal or
            self.sect1 or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='descriptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('descriptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'descriptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='descriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='descriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='descriptionType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='descriptionType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for internal_ in self.internal:
            namespaceprefix_ = self.internal_nsprefix_ + ':' if (UseCapturedNS_ and self.internal_nsprefix_) else ''
            internal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='internal', pretty_print=pretty_print)
        for sect1_ in self.sect1:
            namespaceprefix_ = self.sect1_nsprefix_ + ':' if (UseCapturedNS_ and self.sect1_nsprefix_) else ''
            sect1_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sect1', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'title')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'title')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'title', valuestr_)
            self.content_.append(obj_)
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
                self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
                self.set_para(obj_.value)
        elif nodeName_ == 'internal':
            obj_ = docInternalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'internal', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_internal'):
                self.add_internal(obj_.value)
            elif hasattr(self, 'set_internal'):
                self.set_internal(obj_.value)
        elif nodeName_ == 'sect1':
            obj_ = docSect1Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sect1', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sect1'):
                self.add_sect1(obj_.value)
            elif hasattr(self, 'set_sect1'):
                self.set_sect1(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class descriptionType


class enumvalueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, prot=None, name=None, initializer=None, briefdescription=None, detaileddescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.prot = _cast(None, prot)
        self.prot_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.initializer = initializer
        self.initializer_nsprefix_ = None
        self.briefdescription = briefdescription
        self.briefdescription_nsprefix_ = None
        self.detaileddescription = detaileddescription
        self.detaileddescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enumvalueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enumvalueType.subclass:
            return enumvalueType.subclass(*args_, **kwargs_)
        else:
            return enumvalueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_initializer(self):
        return self.initializer
    def set_initializer(self, initializer):
        self.initializer = initializer
    def get_briefdescription(self):
        return self.briefdescription
    def set_briefdescription(self, briefdescription):
        self.briefdescription = briefdescription
    def get_detaileddescription(self):
        return self.detaileddescription
    def set_detaileddescription(self, detaileddescription):
        self.detaileddescription = detaileddescription
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_prot(self):
        return self.prot
    def set_prot(self, prot):
        self.prot = prot
    def validate_DoxProtectionKind(self, value):
        # Validate type DoxProtectionKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['public', 'protected', 'private', 'package']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxProtectionKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.name is not None or
            self.initializer is not None or
            self.briefdescription is not None or
            self.detaileddescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='enumvalueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('enumvalueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'enumvalueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='enumvalueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='enumvalueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='enumvalueType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.prot is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            outfile.write(' prot=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prot), input_name='prot')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='enumvalueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.initializer is not None:
            namespaceprefix_ = self.initializer_nsprefix_ + ':' if (UseCapturedNS_ and self.initializer_nsprefix_) else ''
            self.initializer.export(outfile, level, namespaceprefix_, namespacedef_='', name_='initializer', pretty_print=pretty_print)
        if self.briefdescription is not None:
            namespaceprefix_ = self.briefdescription_nsprefix_ + ':' if (UseCapturedNS_ and self.briefdescription_nsprefix_) else ''
            self.briefdescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='briefdescription', pretty_print=pretty_print)
        if self.detaileddescription is not None:
            namespaceprefix_ = self.detaileddescription_nsprefix_ + ':' if (UseCapturedNS_ and self.detaileddescription_nsprefix_) else ''
            self.detaileddescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detaileddescription', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('prot', node)
        if value is not None and 'prot' not in already_processed:
            already_processed.add('prot')
            self.prot = value
            self.validate_DoxProtectionKind(self.prot)    # validate type DoxProtectionKind
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'initializer':
            obj_ = linkedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.initializer = obj_
            obj_.original_tagname_ = 'initializer'
        elif nodeName_ == 'briefdescription':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.briefdescription = obj_
            obj_.original_tagname_ = 'briefdescription'
        elif nodeName_ == 'detaileddescription':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.detaileddescription = obj_
            obj_.original_tagname_ = 'detaileddescription'
# end class enumvalueType


class templateparamlistType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, param=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if param is None:
            self.param = []
        else:
            self.param = param
        self.param_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, templateparamlistType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if templateparamlistType.subclass:
            return templateparamlistType.subclass(*args_, **kwargs_)
        else:
            return templateparamlistType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_param(self):
        return self.param
    def set_param(self, param):
        self.param = param
    def add_param(self, value):
        self.param.append(value)
    def insert_param_at(self, index, value):
        self.param.insert(index, value)
    def replace_param_at(self, index, value):
        self.param[index] = value
    def hasContent_(self):
        if (
            self.param
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='templateparamlistType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('templateparamlistType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'templateparamlistType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='templateparamlistType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='templateparamlistType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='templateparamlistType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='templateparamlistType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for param_ in self.param:
            namespaceprefix_ = self.param_nsprefix_ + ':' if (UseCapturedNS_ and self.param_nsprefix_) else ''
            param_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='param', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'param':
            obj_ = paramType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
# end class templateparamlistType


class paramType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, attributes=None, type_=None, declname=None, defname=None, array=None, defval=None, typeconstraint=None, briefdescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.attributes = attributes
        self.attributes_nsprefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
        self.declname = declname
        self.declname_nsprefix_ = None
        self.defname = defname
        self.defname_nsprefix_ = None
        self.array = array
        self.array_nsprefix_ = None
        self.defval = defval
        self.defval_nsprefix_ = None
        self.typeconstraint = typeconstraint
        self.typeconstraint_nsprefix_ = None
        self.briefdescription = briefdescription
        self.briefdescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, paramType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if paramType.subclass:
            return paramType.subclass(*args_, **kwargs_)
        else:
            return paramType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributes(self):
        return self.attributes
    def set_attributes(self, attributes):
        self.attributes = attributes
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_declname(self):
        return self.declname
    def set_declname(self, declname):
        self.declname = declname
    def get_defname(self):
        return self.defname
    def set_defname(self, defname):
        self.defname = defname
    def get_array(self):
        return self.array
    def set_array(self, array):
        self.array = array
    def get_defval(self):
        return self.defval
    def set_defval(self, defval):
        self.defval = defval
    def get_typeconstraint(self):
        return self.typeconstraint
    def set_typeconstraint(self, typeconstraint):
        self.typeconstraint = typeconstraint
    def get_briefdescription(self):
        return self.briefdescription
    def set_briefdescription(self, briefdescription):
        self.briefdescription = briefdescription
    def hasContent_(self):
        if (
            self.attributes is not None or
            self.type_ is not None or
            self.declname is not None or
            self.defname is not None or
            self.array is not None or
            self.defval is not None or
            self.typeconstraint is not None or
            self.briefdescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='paramType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('paramType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'paramType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='paramType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='paramType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='paramType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='paramType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attributes is not None:
            namespaceprefix_ = self.attributes_nsprefix_ + ':' if (UseCapturedNS_ and self.attributes_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributes>%s</%sattributes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.attributes), input_name='attributes')), namespaceprefix_ , eol_))
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        if self.declname is not None:
            namespaceprefix_ = self.declname_nsprefix_ + ':' if (UseCapturedNS_ and self.declname_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeclname>%s</%sdeclname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.declname), input_name='declname')), namespaceprefix_ , eol_))
        if self.defname is not None:
            namespaceprefix_ = self.defname_nsprefix_ + ':' if (UseCapturedNS_ and self.defname_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefname>%s</%sdefname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.defname), input_name='defname')), namespaceprefix_ , eol_))
        if self.array is not None:
            namespaceprefix_ = self.array_nsprefix_ + ':' if (UseCapturedNS_ and self.array_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarray>%s</%sarray>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.array), input_name='array')), namespaceprefix_ , eol_))
        if self.defval is not None:
            namespaceprefix_ = self.defval_nsprefix_ + ':' if (UseCapturedNS_ and self.defval_nsprefix_) else ''
            self.defval.export(outfile, level, namespaceprefix_, namespacedef_='', name_='defval', pretty_print=pretty_print)
        if self.typeconstraint is not None:
            namespaceprefix_ = self.typeconstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.typeconstraint_nsprefix_) else ''
            self.typeconstraint.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeconstraint', pretty_print=pretty_print)
        if self.briefdescription is not None:
            namespaceprefix_ = self.briefdescription_nsprefix_ + ':' if (UseCapturedNS_ and self.briefdescription_nsprefix_) else ''
            self.briefdescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='briefdescription', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributes':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'attributes')
            value_ = self.gds_validate_string(value_, node, 'attributes')
            self.attributes = value_
            self.attributes_nsprefix_ = child_.prefix
        elif nodeName_ == 'type':
            obj_ = linkedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'declname':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'declname')
            value_ = self.gds_validate_string(value_, node, 'declname')
            self.declname = value_
            self.declname_nsprefix_ = child_.prefix
        elif nodeName_ == 'defname':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'defname')
            value_ = self.gds_validate_string(value_, node, 'defname')
            self.defname = value_
            self.defname_nsprefix_ = child_.prefix
        elif nodeName_ == 'array':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'array')
            value_ = self.gds_validate_string(value_, node, 'array')
            self.array = value_
            self.array_nsprefix_ = child_.prefix
        elif nodeName_ == 'defval':
            obj_ = linkedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defval = obj_
            obj_.original_tagname_ = 'defval'
        elif nodeName_ == 'typeconstraint':
            obj_ = linkedTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeconstraint = obj_
            obj_.original_tagname_ = 'typeconstraint'
        elif nodeName_ == 'briefdescription':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.briefdescription = obj_
            obj_.original_tagname_ = 'briefdescription'
# end class paramType


class attributes(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, attributes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if attributes.subclass:
            return attributes.subclass(*args_, **kwargs_)
        else:
            return attributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='attributes', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('attributes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'attributes':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='attributes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='attributes', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='attributes'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='attributes', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class attributes


class declname(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, declname)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if declname.subclass:
            return declname.subclass(*args_, **kwargs_)
        else:
            return declname(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='declname', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('declname')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'declname':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='declname')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='declname', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='declname'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='declname', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class declname


class defname(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, defname)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if defname.subclass:
            return defname.subclass(*args_, **kwargs_)
        else:
            return defname(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='defname', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('defname')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'defname':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='defname')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='defname', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='defname'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='defname', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class defname


class array(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, array)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if array.subclass:
            return array.subclass(*args_, **kwargs_)
        else:
            return array(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='array', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('array')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'array':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='array')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='array', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='array'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='array', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class array


class linkedTextType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ref=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, linkedTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if linkedTextType.subclass:
            return linkedTextType.subclass(*args_, **kwargs_)
        else:
            return linkedTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ref or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='linkedTextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('linkedTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'linkedTextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='linkedTextType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='linkedTextType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='linkedTextType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='linkedTextType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ref':
            obj_ = refTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class linkedTextType


class graphType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, node=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if node is None:
            self.node = []
        else:
            self.node = node
        self.node_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, graphType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if graphType.subclass:
            return graphType.subclass(*args_, **kwargs_)
        else:
            return graphType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_node(self):
        return self.node
    def set_node(self, node):
        self.node = node
    def add_node(self, value):
        self.node.append(value)
    def insert_node_at(self, index, value):
        self.node.insert(index, value)
    def replace_node_at(self, index, value):
        self.node[index] = value
    def hasContent_(self):
        if (
            self.node
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='graphType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('graphType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'graphType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='graphType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='graphType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='graphType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='graphType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for node_ in self.node:
            namespaceprefix_ = self.node_nsprefix_ + ':' if (UseCapturedNS_ and self.node_nsprefix_) else ''
            node_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='node', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'node':
            obj_ = nodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.node.append(obj_)
            obj_.original_tagname_ = 'node'
# end class graphType


class nodeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, label=None, link=None, childnode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.label = label
        self.label_nsprefix_ = None
        self.link = link
        self.link_nsprefix_ = None
        if childnode is None:
            self.childnode = []
        else:
            self.childnode = childnode
        self.childnode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nodeType.subclass:
            return nodeType.subclass(*args_, **kwargs_)
        else:
            return nodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def get_childnode(self):
        return self.childnode
    def set_childnode(self, childnode):
        self.childnode = childnode
    def add_childnode(self, value):
        self.childnode.append(value)
    def insert_childnode_at(self, index, value):
        self.childnode.insert(index, value)
    def replace_childnode_at(self, index, value):
        self.childnode[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.label is not None or
            self.link is not None or
            self.childnode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='nodeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nodeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'nodeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nodeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='nodeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nodeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='nodeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.label is not None:
            namespaceprefix_ = self.label_nsprefix_ + ':' if (UseCapturedNS_ and self.label_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slabel>%s</%slabel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.label), input_name='label')), namespaceprefix_ , eol_))
        if self.link is not None:
            namespaceprefix_ = self.link_nsprefix_ + ':' if (UseCapturedNS_ and self.link_nsprefix_) else ''
            self.link.export(outfile, level, namespaceprefix_, namespacedef_='', name_='link', pretty_print=pretty_print)
        for childnode_ in self.childnode:
            namespaceprefix_ = self.childnode_nsprefix_ + ':' if (UseCapturedNS_ and self.childnode_nsprefix_) else ''
            childnode_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='childnode', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'label':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'label')
            value_ = self.gds_validate_string(value_, node, 'label')
            self.label = value_
            self.label_nsprefix_ = child_.prefix
        elif nodeName_ == 'link':
            obj_ = linkType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.link = obj_
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'childnode':
            obj_ = childnodeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.childnode.append(obj_)
            obj_.original_tagname_ = 'childnode'
# end class nodeType


class label(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, label)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if label.subclass:
            return label.subclass(*args_, **kwargs_)
        else:
            return label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='label', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('label')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'label':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='label')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='label', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='label'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='label', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class label


class childnodeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, relation=None, edgelabel=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.relation = _cast(None, relation)
        self.relation_nsprefix_ = None
        if edgelabel is None:
            self.edgelabel = []
        else:
            self.edgelabel = edgelabel
        self.edgelabel_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, childnodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if childnodeType.subclass:
            return childnodeType.subclass(*args_, **kwargs_)
        else:
            return childnodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_edgelabel(self):
        return self.edgelabel
    def set_edgelabel(self, edgelabel):
        self.edgelabel = edgelabel
    def add_edgelabel(self, value):
        self.edgelabel.append(value)
    def insert_edgelabel_at(self, index, value):
        self.edgelabel.insert(index, value)
    def replace_edgelabel_at(self, index, value):
        self.edgelabel[index] = value
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_relation(self):
        return self.relation
    def set_relation(self, relation):
        self.relation = relation
    def validate_DoxGraphRelation(self, value):
        # Validate type DoxGraphRelation, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['include', 'usage', 'template-instance', 'public-inheritance', 'protected-inheritance', 'private-inheritance', 'type-constraint']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxGraphRelation' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.edgelabel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='childnodeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('childnodeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'childnodeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='childnodeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='childnodeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='childnodeType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.relation is not None and 'relation' not in already_processed:
            already_processed.add('relation')
            outfile.write(' relation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.relation), input_name='relation')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='childnodeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for edgelabel_ in self.edgelabel:
            namespaceprefix_ = self.edgelabel_nsprefix_ + ':' if (UseCapturedNS_ and self.edgelabel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sedgelabel>%s</%sedgelabel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(edgelabel_), input_name='edgelabel')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('relation', node)
        if value is not None and 'relation' not in already_processed:
            already_processed.add('relation')
            self.relation = value
            self.validate_DoxGraphRelation(self.relation)    # validate type DoxGraphRelation
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'edgelabel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'edgelabel')
            value_ = self.gds_validate_string(value_, node, 'edgelabel')
            self.edgelabel.append(value_)
            self.edgelabel_nsprefix_ = child_.prefix
# end class childnodeType


class edgelabel(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, edgelabel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if edgelabel.subclass:
            return edgelabel.subclass(*args_, **kwargs_)
        else:
            return edgelabel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='edgelabel', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('edgelabel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'edgelabel':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='edgelabel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='edgelabel', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='edgelabel'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='edgelabel', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class edgelabel


class linkType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, external=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.external = _cast(None, external)
        self.external_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, linkType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if linkType.subclass:
            return linkType.subclass(*args_, **kwargs_)
        else:
            return linkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_external(self):
        return self.external
    def set_external(self, external):
        self.external = external
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='linkType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('linkType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'linkType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='linkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='linkType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='linkType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.external is not None and 'external' not in already_processed:
            already_processed.add('external')
            outfile.write(' external=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.external), input_name='external')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='linkType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('external', node)
        if value is not None and 'external' not in already_processed:
            already_processed.add('external')
            self.external = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class linkType


class listingType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, filename=None, codeline=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.filename = _cast(None, filename)
        self.filename_nsprefix_ = None
        if codeline is None:
            self.codeline = []
        else:
            self.codeline = codeline
        self.codeline_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listingType.subclass:
            return listingType.subclass(*args_, **kwargs_)
        else:
            return listingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_codeline(self):
        return self.codeline
    def set_codeline(self, codeline):
        self.codeline = codeline
    def add_codeline(self, value):
        self.codeline.append(value)
    def insert_codeline_at(self, index, value):
        self.codeline.insert(index, value)
    def replace_codeline_at(self, index, value):
        self.codeline[index] = value
    def get_filename(self):
        return self.filename
    def set_filename(self, filename):
        self.filename = filename
    def hasContent_(self):
        if (
            self.codeline
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'listingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listingType'):
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filename), input_name='filename')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for codeline_ in self.codeline:
            namespaceprefix_ = self.codeline_nsprefix_ + ':' if (UseCapturedNS_ and self.codeline_nsprefix_) else ''
            codeline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='codeline', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'codeline':
            obj_ = codelineType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.codeline.append(obj_)
            obj_.original_tagname_ = 'codeline'
# end class listingType


class codelineType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lineno=None, refid=None, refkind=None, external=None, highlight=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lineno = _cast(int, lineno)
        self.lineno_nsprefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.refkind = _cast(None, refkind)
        self.refkind_nsprefix_ = None
        self.external = _cast(None, external)
        self.external_nsprefix_ = None
        if highlight is None:
            self.highlight = []
        else:
            self.highlight = highlight
        self.highlight_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codelineType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codelineType.subclass:
            return codelineType.subclass(*args_, **kwargs_)
        else:
            return codelineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_highlight(self):
        return self.highlight
    def set_highlight(self, highlight):
        self.highlight = highlight
    def add_highlight(self, value):
        self.highlight.append(value)
    def insert_highlight_at(self, index, value):
        self.highlight.insert(index, value)
    def replace_highlight_at(self, index, value):
        self.highlight[index] = value
    def get_lineno(self):
        return self.lineno
    def set_lineno(self, lineno):
        self.lineno = lineno
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_refkind(self):
        return self.refkind
    def set_refkind(self, refkind):
        self.refkind = refkind
    def get_external(self):
        return self.external
    def set_external(self, external):
        self.external = external
    def validate_DoxRefKind(self, value):
        # Validate type DoxRefKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['compound', 'member']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxRefKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxBool(self, value):
        # Validate type DoxBool, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxBool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.highlight
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='codelineType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codelineType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'codelineType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='codelineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='codelineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='codelineType'):
        if self.lineno is not None and 'lineno' not in already_processed:
            already_processed.add('lineno')
            outfile.write(' lineno="%s"' % self.gds_format_integer(self.lineno, input_name='lineno'))
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.refkind is not None and 'refkind' not in already_processed:
            already_processed.add('refkind')
            outfile.write(' refkind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refkind), input_name='refkind')), ))
        if self.external is not None and 'external' not in already_processed:
            already_processed.add('external')
            outfile.write(' external=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.external), input_name='external')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='codelineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for highlight_ in self.highlight:
            namespaceprefix_ = self.highlight_nsprefix_ + ':' if (UseCapturedNS_ and self.highlight_nsprefix_) else ''
            highlight_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='highlight', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lineno', node)
        if value is not None and 'lineno' not in already_processed:
            already_processed.add('lineno')
            self.lineno = self.gds_parse_integer(value, node, 'lineno')
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('refkind', node)
        if value is not None and 'refkind' not in already_processed:
            already_processed.add('refkind')
            self.refkind = value
            self.validate_DoxRefKind(self.refkind)    # validate type DoxRefKind
        value = find_attr_value_('external', node)
        if value is not None and 'external' not in already_processed:
            already_processed.add('external')
            self.external = value
            self.validate_DoxBool(self.external)    # validate type DoxBool
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'highlight':
            obj_ = highlightType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.highlight.append(obj_)
            obj_.original_tagname_ = 'highlight'
# end class codelineType


class highlightType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, class_=None, sp=None, ref=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.class_ = _cast(None, class_)
        self.class__nsprefix_ = None
        if sp is None:
            self.sp = []
        else:
            self.sp = sp
        self.sp_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, highlightType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if highlightType.subclass:
            return highlightType.subclass(*args_, **kwargs_)
        else:
            return highlightType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sp(self):
        return self.sp
    def set_sp(self, sp):
        self.sp = sp
    def add_sp(self, value):
        self.sp.append(value)
    def insert_sp_at(self, index, value):
        self.sp.insert(index, value)
    def replace_sp_at(self, index, value):
        self.sp[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_class(self):
        return self.class_
    def set_class(self, class_):
        self.class_ = class_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DoxHighlightClass(self, value):
        # Validate type DoxHighlightClass, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['comment', 'normal', 'preprocessor', 'keyword', 'keywordtype', 'keywordflow', 'stringliteral', 'xmlcdata', 'charliteral', 'vhdlkeyword', 'vhdllogic', 'vhdlchar', 'vhdldigit']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxHighlightClass' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.sp or
            self.ref or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='highlightType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('highlightType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'highlightType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='highlightType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='highlightType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='highlightType'):
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='highlightType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sp_ in self.sp:
            namespaceprefix_ = self.sp_nsprefix_ + ':' if (UseCapturedNS_ and self.sp_nsprefix_) else ''
            sp_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sp', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
            self.validate_DoxHighlightClass(self.class_)    # validate type DoxHighlightClass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sp':
            obj_ = spType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sp', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sp'):
                self.add_sp(obj_.value)
            elif hasattr(self, 'set_sp'):
                self.set_sp(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = refTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class highlightType


class spType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(int, value)
        self.value_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, spType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if spType.subclass:
            return spType.subclass(*args_, **kwargs_)
        else:
            return spType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='spType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('spType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'spType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='spType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='spType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='spType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = self.gds_parse_integer(value, node, 'value')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class spType


class referenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, compoundref=None, startline=None, endline=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.compoundref = _cast(None, compoundref)
        self.compoundref_nsprefix_ = None
        self.startline = _cast(int, startline)
        self.startline_nsprefix_ = None
        self.endline = _cast(int, endline)
        self.endline_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, referenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if referenceType.subclass:
            return referenceType.subclass(*args_, **kwargs_)
        else:
            return referenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_compoundref(self):
        return self.compoundref
    def set_compoundref(self, compoundref):
        self.compoundref = compoundref
    def get_startline(self):
        return self.startline
    def set_startline(self, startline):
        self.startline = startline
    def get_endline(self):
        return self.endline
    def set_endline(self, endline):
        self.endline = endline
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='referenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('referenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'referenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='referenceType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='referenceType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.compoundref is not None and 'compoundref' not in already_processed:
            already_processed.add('compoundref')
            outfile.write(' compoundref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.compoundref), input_name='compoundref')), ))
        if self.startline is not None and 'startline' not in already_processed:
            already_processed.add('startline')
            outfile.write(' startline="%s"' % self.gds_format_integer(self.startline, input_name='startline'))
        if self.endline is not None and 'endline' not in already_processed:
            already_processed.add('endline')
            outfile.write(' endline="%s"' % self.gds_format_integer(self.endline, input_name='endline'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='referenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('compoundref', node)
        if value is not None and 'compoundref' not in already_processed:
            already_processed.add('compoundref')
            self.compoundref = value
        value = find_attr_value_('startline', node)
        if value is not None and 'startline' not in already_processed:
            already_processed.add('startline')
            self.startline = self.gds_parse_integer(value, node, 'startline')
        value = find_attr_value_('endline', node)
        if value is not None and 'endline' not in already_processed:
            already_processed.add('endline')
            self.endline = self.gds_parse_integer(value, node, 'endline')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class referenceType


class locationType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, file=None, line=None, column=None, declfile=None, declline=None, declcolumn=None, bodyfile=None, bodystart=None, bodyend=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.file = _cast(None, file)
        self.file_nsprefix_ = None
        self.line = _cast(int, line)
        self.line_nsprefix_ = None
        self.column = _cast(int, column)
        self.column_nsprefix_ = None
        self.declfile = _cast(None, declfile)
        self.declfile_nsprefix_ = None
        self.declline = _cast(int, declline)
        self.declline_nsprefix_ = None
        self.declcolumn = _cast(int, declcolumn)
        self.declcolumn_nsprefix_ = None
        self.bodyfile = _cast(None, bodyfile)
        self.bodyfile_nsprefix_ = None
        self.bodystart = _cast(int, bodystart)
        self.bodystart_nsprefix_ = None
        self.bodyend = _cast(int, bodyend)
        self.bodyend_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, locationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if locationType.subclass:
            return locationType.subclass(*args_, **kwargs_)
        else:
            return locationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def get_column(self):
        return self.column
    def set_column(self, column):
        self.column = column
    def get_declfile(self):
        return self.declfile
    def set_declfile(self, declfile):
        self.declfile = declfile
    def get_declline(self):
        return self.declline
    def set_declline(self, declline):
        self.declline = declline
    def get_declcolumn(self):
        return self.declcolumn
    def set_declcolumn(self, declcolumn):
        self.declcolumn = declcolumn
    def get_bodyfile(self):
        return self.bodyfile
    def set_bodyfile(self, bodyfile):
        self.bodyfile = bodyfile
    def get_bodystart(self):
        return self.bodystart
    def set_bodystart(self, bodystart):
        self.bodystart = bodystart
    def get_bodyend(self):
        return self.bodyend
    def set_bodyend(self, bodyend):
        self.bodyend = bodyend
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='locationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('locationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'locationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='locationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='locationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='locationType'):
        if self.file is not None and 'file' not in already_processed:
            already_processed.add('file')
            outfile.write(' file=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.file), input_name='file')), ))
        if self.line is not None and 'line' not in already_processed:
            already_processed.add('line')
            outfile.write(' line="%s"' % self.gds_format_integer(self.line, input_name='line'))
        if self.column is not None and 'column' not in already_processed:
            already_processed.add('column')
            outfile.write(' column="%s"' % self.gds_format_integer(self.column, input_name='column'))
        if self.declfile is not None and 'declfile' not in already_processed:
            already_processed.add('declfile')
            outfile.write(' declfile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.declfile), input_name='declfile')), ))
        if self.declline is not None and 'declline' not in already_processed:
            already_processed.add('declline')
            outfile.write(' declline="%s"' % self.gds_format_integer(self.declline, input_name='declline'))
        if self.declcolumn is not None and 'declcolumn' not in already_processed:
            already_processed.add('declcolumn')
            outfile.write(' declcolumn="%s"' % self.gds_format_integer(self.declcolumn, input_name='declcolumn'))
        if self.bodyfile is not None and 'bodyfile' not in already_processed:
            already_processed.add('bodyfile')
            outfile.write(' bodyfile=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bodyfile), input_name='bodyfile')), ))
        if self.bodystart is not None and 'bodystart' not in already_processed:
            already_processed.add('bodystart')
            outfile.write(' bodystart="%s"' % self.gds_format_integer(self.bodystart, input_name='bodystart'))
        if self.bodyend is not None and 'bodyend' not in already_processed:
            already_processed.add('bodyend')
            outfile.write(' bodyend="%s"' % self.gds_format_integer(self.bodyend, input_name='bodyend'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='locationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('file', node)
        if value is not None and 'file' not in already_processed:
            already_processed.add('file')
            self.file = value
        value = find_attr_value_('line', node)
        if value is not None and 'line' not in already_processed:
            already_processed.add('line')
            self.line = self.gds_parse_integer(value, node, 'line')
        value = find_attr_value_('column', node)
        if value is not None and 'column' not in already_processed:
            already_processed.add('column')
            self.column = self.gds_parse_integer(value, node, 'column')
        value = find_attr_value_('declfile', node)
        if value is not None and 'declfile' not in already_processed:
            already_processed.add('declfile')
            self.declfile = value
        value = find_attr_value_('declline', node)
        if value is not None and 'declline' not in already_processed:
            already_processed.add('declline')
            self.declline = self.gds_parse_integer(value, node, 'declline')
        value = find_attr_value_('declcolumn', node)
        if value is not None and 'declcolumn' not in already_processed:
            already_processed.add('declcolumn')
            self.declcolumn = self.gds_parse_integer(value, node, 'declcolumn')
        value = find_attr_value_('bodyfile', node)
        if value is not None and 'bodyfile' not in already_processed:
            already_processed.add('bodyfile')
            self.bodyfile = value
        value = find_attr_value_('bodystart', node)
        if value is not None and 'bodystart' not in already_processed:
            already_processed.add('bodystart')
            self.bodystart = self.gds_parse_integer(value, node, 'bodystart')
        value = find_attr_value_('bodyend', node)
        if value is not None and 'bodyend' not in already_processed:
            already_processed.add('bodyend')
            self.bodyend = self.gds_parse_integer(value, node, 'bodyend')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class locationType


class docSect1Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, para=None, internal=None, sect2=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if internal is None:
            self.internal = []
        else:
            self.internal = internal
        self.internal_nsprefix_ = None
        if sect2 is None:
            self.sect2 = []
        else:
            self.sect2 = sect2
        self.sect2_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docSect1Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docSect1Type.subclass:
            return docSect1Type.subclass(*args_, **kwargs_)
        else:
            return docSect1Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_internal(self):
        return self.internal
    def set_internal(self, internal):
        self.internal = internal
    def add_internal(self, value):
        self.internal.append(value)
    def insert_internal_at(self, index, value):
        self.internal.insert(index, value)
    def replace_internal_at(self, index, value):
        self.internal[index] = value
    def get_sect2(self):
        return self.sect2
    def set_sect2(self, sect2):
        self.sect2 = sect2
    def add_sect2(self, value):
        self.sect2.append(value)
    def insert_sect2_at(self, index, value):
        self.sect2.insert(index, value)
    def replace_sect2_at(self, index, value):
        self.sect2[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.title is not None or
            self.para or
            self.internal or
            self.sect2 or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSect1Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docSect1Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docSect1Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docSect1Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docSect1Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docSect1Type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSect1Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for internal_ in self.internal:
            namespaceprefix_ = self.internal_nsprefix_ + ':' if (UseCapturedNS_ and self.internal_nsprefix_) else ''
            internal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='internal', pretty_print=pretty_print)
        for sect2_ in self.sect2:
            namespaceprefix_ = self.sect2_nsprefix_ + ':' if (UseCapturedNS_ and self.sect2_nsprefix_) else ''
            sect2_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sect2', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'title')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'title')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'title', valuestr_)
            self.content_.append(obj_)
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
                self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
                self.set_para(obj_.value)
        elif nodeName_ == 'internal':
            obj_ = docInternalS1Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'internal', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_internal'):
                self.add_internal(obj_.value)
            elif hasattr(self, 'set_internal'):
                self.set_internal(obj_.value)
        elif nodeName_ == 'sect2':
            obj_ = docSect2Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sect2', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sect2'):
                self.add_sect2(obj_.value)
            elif hasattr(self, 'set_sect2'):
                self.set_sect2(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docSect1Type


class docSect2Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, para=None, sect3=None, internal=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if sect3 is None:
            self.sect3 = []
        else:
            self.sect3 = sect3
        self.sect3_nsprefix_ = None
        if internal is None:
            self.internal = []
        else:
            self.internal = internal
        self.internal_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docSect2Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docSect2Type.subclass:
            return docSect2Type.subclass(*args_, **kwargs_)
        else:
            return docSect2Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_sect3(self):
        return self.sect3
    def set_sect3(self, sect3):
        self.sect3 = sect3
    def add_sect3(self, value):
        self.sect3.append(value)
    def insert_sect3_at(self, index, value):
        self.sect3.insert(index, value)
    def replace_sect3_at(self, index, value):
        self.sect3[index] = value
    def get_internal(self):
        return self.internal
    def set_internal(self, internal):
        self.internal = internal
    def add_internal(self, value):
        self.internal.append(value)
    def insert_internal_at(self, index, value):
        self.internal.insert(index, value)
    def replace_internal_at(self, index, value):
        self.internal[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.title is not None or
            self.para or
            self.sect3 or
            self.internal or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSect2Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docSect2Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docSect2Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docSect2Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docSect2Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docSect2Type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSect2Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for sect3_ in self.sect3:
            namespaceprefix_ = self.sect3_nsprefix_ + ':' if (UseCapturedNS_ and self.sect3_nsprefix_) else ''
            sect3_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sect3', pretty_print=pretty_print)
        for internal_ in self.internal:
            namespaceprefix_ = self.internal_nsprefix_ + ':' if (UseCapturedNS_ and self.internal_nsprefix_) else ''
            internal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='internal', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'title')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'title')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'title', valuestr_)
            self.content_.append(obj_)
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
                self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
                self.set_para(obj_.value)
        elif nodeName_ == 'sect3':
            obj_ = docSect3Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sect3', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sect3'):
                self.add_sect3(obj_.value)
            elif hasattr(self, 'set_sect3'):
                self.set_sect3(obj_.value)
        elif nodeName_ == 'internal':
            obj_ = docInternalS2Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'internal', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_internal'):
                self.add_internal(obj_.value)
            elif hasattr(self, 'set_internal'):
                self.set_internal(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docSect2Type


class docSect3Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, para=None, sect4=None, internal=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if sect4 is None:
            self.sect4 = []
        else:
            self.sect4 = sect4
        self.sect4_nsprefix_ = None
        if internal is None:
            self.internal = []
        else:
            self.internal = internal
        self.internal_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docSect3Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docSect3Type.subclass:
            return docSect3Type.subclass(*args_, **kwargs_)
        else:
            return docSect3Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_sect4(self):
        return self.sect4
    def set_sect4(self, sect4):
        self.sect4 = sect4
    def add_sect4(self, value):
        self.sect4.append(value)
    def insert_sect4_at(self, index, value):
        self.sect4.insert(index, value)
    def replace_sect4_at(self, index, value):
        self.sect4[index] = value
    def get_internal(self):
        return self.internal
    def set_internal(self, internal):
        self.internal = internal
    def add_internal(self, value):
        self.internal.append(value)
    def insert_internal_at(self, index, value):
        self.internal.insert(index, value)
    def replace_internal_at(self, index, value):
        self.internal[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.title is not None or
            self.para or
            self.sect4 or
            self.internal or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSect3Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docSect3Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docSect3Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docSect3Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docSect3Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docSect3Type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSect3Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for sect4_ in self.sect4:
            namespaceprefix_ = self.sect4_nsprefix_ + ':' if (UseCapturedNS_ and self.sect4_nsprefix_) else ''
            sect4_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sect4', pretty_print=pretty_print)
        for internal_ in self.internal:
            namespaceprefix_ = self.internal_nsprefix_ + ':' if (UseCapturedNS_ and self.internal_nsprefix_) else ''
            internal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='internal', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'title')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'title')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'title', valuestr_)
            self.content_.append(obj_)
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
                self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
                self.set_para(obj_.value)
        elif nodeName_ == 'sect4':
            obj_ = docSect4Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sect4', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sect4'):
                self.add_sect4(obj_.value)
            elif hasattr(self, 'set_sect4'):
                self.set_sect4(obj_.value)
        elif nodeName_ == 'internal':
            obj_ = docInternalS3Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'internal', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_internal'):
                self.add_internal(obj_.value)
            elif hasattr(self, 'set_internal'):
                self.set_internal(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docSect3Type


class docSect4Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, title=None, para=None, internal=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if internal is None:
            self.internal = []
        else:
            self.internal = internal
        self.internal_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docSect4Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docSect4Type.subclass:
            return docSect4Type.subclass(*args_, **kwargs_)
        else:
            return docSect4Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_internal(self):
        return self.internal
    def set_internal(self, internal):
        self.internal = internal
    def add_internal(self, value):
        self.internal.append(value)
    def insert_internal_at(self, index, value):
        self.internal.insert(index, value)
    def replace_internal_at(self, index, value):
        self.internal[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.title is not None or
            self.para or
            self.internal or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSect4Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docSect4Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docSect4Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docSect4Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docSect4Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docSect4Type'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSect4Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for internal_ in self.internal:
            namespaceprefix_ = self.internal_nsprefix_ + ':' if (UseCapturedNS_ and self.internal_nsprefix_) else ''
            internal_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='internal', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'title')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'title')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'title', valuestr_)
            self.content_.append(obj_)
            self.title_nsprefix_ = child_.prefix
        elif nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
                self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
                self.set_para(obj_.value)
        elif nodeName_ == 'internal':
            obj_ = docInternalS4Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'internal', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_internal'):
                self.add_internal(obj_.value)
            elif hasattr(self, 'set_internal'):
                self.set_internal(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docSect4Type


class docInternalType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, para=None, sect1=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if sect1 is None:
            self.sect1 = []
        else:
            self.sect1 = sect1
        self.sect1_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docInternalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docInternalType.subclass:
            return docInternalType.subclass(*args_, **kwargs_)
        else:
            return docInternalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_sect1(self):
        return self.sect1
    def set_sect1(self, sect1):
        self.sect1 = sect1
    def add_sect1(self, value):
        self.sect1.append(value)
    def insert_sect1_at(self, index, value):
        self.sect1.insert(index, value)
    def replace_sect1_at(self, index, value):
        self.sect1[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.para or
            self.sect1 or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docInternalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docInternalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docInternalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docInternalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docInternalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docInternalType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docInternalType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for sect1_ in self.sect1:
            namespaceprefix_ = self.sect1_nsprefix_ + ':' if (UseCapturedNS_ and self.sect1_nsprefix_) else ''
            sect1_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sect1', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
                self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
                self.set_para(obj_.value)
        elif nodeName_ == 'sect1':
            obj_ = docSect1Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sect1', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sect1'):
                self.add_sect1(obj_.value)
            elif hasattr(self, 'set_sect1'):
                self.set_sect1(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docInternalType


class docInternalS1Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, para=None, sect2=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if sect2 is None:
            self.sect2 = []
        else:
            self.sect2 = sect2
        self.sect2_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docInternalS1Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docInternalS1Type.subclass:
            return docInternalS1Type.subclass(*args_, **kwargs_)
        else:
            return docInternalS1Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_sect2(self):
        return self.sect2
    def set_sect2(self, sect2):
        self.sect2 = sect2
    def add_sect2(self, value):
        self.sect2.append(value)
    def insert_sect2_at(self, index, value):
        self.sect2.insert(index, value)
    def replace_sect2_at(self, index, value):
        self.sect2[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.para or
            self.sect2 or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docInternalS1Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docInternalS1Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docInternalS1Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docInternalS1Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docInternalS1Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docInternalS1Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docInternalS1Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for sect2_ in self.sect2:
            namespaceprefix_ = self.sect2_nsprefix_ + ':' if (UseCapturedNS_ and self.sect2_nsprefix_) else ''
            sect2_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sect2', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
                self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
                self.set_para(obj_.value)
        elif nodeName_ == 'sect2':
            obj_ = docSect2Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sect2', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sect2'):
                self.add_sect2(obj_.value)
            elif hasattr(self, 'set_sect2'):
                self.set_sect2(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docInternalS1Type


class docInternalS2Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, para=None, sect3=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if sect3 is None:
            self.sect3 = []
        else:
            self.sect3 = sect3
        self.sect3_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docInternalS2Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docInternalS2Type.subclass:
            return docInternalS2Type.subclass(*args_, **kwargs_)
        else:
            return docInternalS2Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_sect3(self):
        return self.sect3
    def set_sect3(self, sect3):
        self.sect3 = sect3
    def add_sect3(self, value):
        self.sect3.append(value)
    def insert_sect3_at(self, index, value):
        self.sect3.insert(index, value)
    def replace_sect3_at(self, index, value):
        self.sect3[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.para or
            self.sect3 or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docInternalS2Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docInternalS2Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docInternalS2Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docInternalS2Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docInternalS2Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docInternalS2Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docInternalS2Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for sect3_ in self.sect3:
            namespaceprefix_ = self.sect3_nsprefix_ + ':' if (UseCapturedNS_ and self.sect3_nsprefix_) else ''
            sect3_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sect3', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
                self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
                self.set_para(obj_.value)
        elif nodeName_ == 'sect3':
            obj_ = docSect3Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sect3', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sect3'):
                self.add_sect3(obj_.value)
            elif hasattr(self, 'set_sect3'):
                self.set_sect3(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docInternalS2Type


class docInternalS3Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, para=None, sect3=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if sect3 is None:
            self.sect3 = []
        else:
            self.sect3 = sect3
        self.sect3_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docInternalS3Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docInternalS3Type.subclass:
            return docInternalS3Type.subclass(*args_, **kwargs_)
        else:
            return docInternalS3Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_sect3(self):
        return self.sect3
    def set_sect3(self, sect3):
        self.sect3 = sect3
    def add_sect3(self, value):
        self.sect3.append(value)
    def insert_sect3_at(self, index, value):
        self.sect3.insert(index, value)
    def replace_sect3_at(self, index, value):
        self.sect3[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.para or
            self.sect3 or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docInternalS3Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docInternalS3Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docInternalS3Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docInternalS3Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docInternalS3Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docInternalS3Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docInternalS3Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for sect3_ in self.sect3:
            namespaceprefix_ = self.sect3_nsprefix_ + ':' if (UseCapturedNS_ and self.sect3_nsprefix_) else ''
            sect3_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sect3', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
                self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
                self.set_para(obj_.value)
        elif nodeName_ == 'sect3':
            obj_ = docSect4Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'sect3', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_sect3'):
                self.add_sect3(obj_.value)
            elif hasattr(self, 'set_sect3'):
                self.set_sect3(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docInternalS3Type


class docInternalS4Type(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, para=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docInternalS4Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docInternalS4Type.subclass:
            return docInternalS4Type.subclass(*args_, **kwargs_)
        else:
            return docInternalS4Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.para or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docInternalS4Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docInternalS4Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docInternalS4Type':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docInternalS4Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docInternalS4Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docInternalS4Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docInternalS4Type', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'para', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_para'):
                self.add_para(obj_.value)
            elif hasattr(self, 'set_para'):
                self.set_para(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docInternalS4Type


class docTitleType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docTitleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docTitleType.subclass:
            return docTitleType.subclass(*args_, **kwargs_)
        else:
            return docTitleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docTitleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docTitleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docTitleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docTitleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docTitleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docTitleType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docTitleType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docTitleType


class docSummaryType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docSummaryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docSummaryType.subclass:
            return docSummaryType.subclass(*args_, **kwargs_)
        else:
            return docSummaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSummaryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docSummaryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docSummaryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docSummaryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docSummaryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docSummaryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSummaryType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docSummaryType


class docParaType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, hruler=None, preformatted=None, programlisting=None, verbatim=None, javadocliteral=None, javadoccode=None, indexentry=None, orderedlist=None, itemizedlist=None, simplesect=None, title=None, variablelist=None, table=None, heading=None, dotfile=None, mscfile=None, diafile=None, toclist=None, language=None, parameterlist=None, xrefsect=None, copydoc=None, details=None, blockquote=None, parblock=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        if hruler is None:
            self.hruler = []
        else:
            self.hruler = hruler
        self.hruler_nsprefix_ = None
        if preformatted is None:
            self.preformatted = []
        else:
            self.preformatted = preformatted
        self.preformatted_nsprefix_ = None
        if programlisting is None:
            self.programlisting = []
        else:
            self.programlisting = programlisting
        self.programlisting_nsprefix_ = None
        if verbatim is None:
            self.verbatim = []
        else:
            self.verbatim = verbatim
        self.verbatim_nsprefix_ = None
        if javadocliteral is None:
            self.javadocliteral = []
        else:
            self.javadocliteral = javadocliteral
        self.javadocliteral_nsprefix_ = None
        if javadoccode is None:
            self.javadoccode = []
        else:
            self.javadoccode = javadoccode
        self.javadoccode_nsprefix_ = None
        if indexentry is None:
            self.indexentry = []
        else:
            self.indexentry = indexentry
        self.indexentry_nsprefix_ = None
        if orderedlist is None:
            self.orderedlist = []
        else:
            self.orderedlist = orderedlist
        self.orderedlist_nsprefix_ = None
        if itemizedlist is None:
            self.itemizedlist = []
        else:
            self.itemizedlist = itemizedlist
        self.itemizedlist_nsprefix_ = None
        if simplesect is None:
            self.simplesect = []
        else:
            self.simplesect = simplesect
        self.simplesect_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
        if variablelist is None:
            self.variablelist = []
        else:
            self.variablelist = variablelist
        self.variablelist_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        if heading is None:
            self.heading = []
        else:
            self.heading = heading
        self.heading_nsprefix_ = None
        if dotfile is None:
            self.dotfile = []
        else:
            self.dotfile = dotfile
        self.dotfile_nsprefix_ = None
        if mscfile is None:
            self.mscfile = []
        else:
            self.mscfile = mscfile
        self.mscfile_nsprefix_ = None
        if diafile is None:
            self.diafile = []
        else:
            self.diafile = diafile
        self.diafile_nsprefix_ = None
        if toclist is None:
            self.toclist = []
        else:
            self.toclist = toclist
        self.toclist_nsprefix_ = None
        if language is None:
            self.language = []
        else:
            self.language = language
        self.language_nsprefix_ = None
        if parameterlist is None:
            self.parameterlist = []
        else:
            self.parameterlist = parameterlist
        self.parameterlist_nsprefix_ = None
        if xrefsect is None:
            self.xrefsect = []
        else:
            self.xrefsect = xrefsect
        self.xrefsect_nsprefix_ = None
        if copydoc is None:
            self.copydoc = []
        else:
            self.copydoc = copydoc
        self.copydoc_nsprefix_ = None
        if details is None:
            self.details = []
        else:
            self.details = details
        self.details_nsprefix_ = None
        if blockquote is None:
            self.blockquote = []
        else:
            self.blockquote = blockquote
        self.blockquote_nsprefix_ = None
        if parblock is None:
            self.parblock = []
        else:
            self.parblock = parblock
        self.parblock_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docParaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docParaType.subclass:
            return docParaType.subclass(*args_, **kwargs_)
        else:
            return docParaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_hruler(self):
        return self.hruler
    def set_hruler(self, hruler):
        self.hruler = hruler
    def add_hruler(self, value):
        self.hruler.append(value)
    def insert_hruler_at(self, index, value):
        self.hruler.insert(index, value)
    def replace_hruler_at(self, index, value):
        self.hruler[index] = value
    def get_preformatted(self):
        return self.preformatted
    def set_preformatted(self, preformatted):
        self.preformatted = preformatted
    def add_preformatted(self, value):
        self.preformatted.append(value)
    def insert_preformatted_at(self, index, value):
        self.preformatted.insert(index, value)
    def replace_preformatted_at(self, index, value):
        self.preformatted[index] = value
    def get_programlisting(self):
        return self.programlisting
    def set_programlisting(self, programlisting):
        self.programlisting = programlisting
    def add_programlisting(self, value):
        self.programlisting.append(value)
    def insert_programlisting_at(self, index, value):
        self.programlisting.insert(index, value)
    def replace_programlisting_at(self, index, value):
        self.programlisting[index] = value
    def get_verbatim(self):
        return self.verbatim
    def set_verbatim(self, verbatim):
        self.verbatim = verbatim
    def add_verbatim(self, value):
        self.verbatim.append(value)
    def insert_verbatim_at(self, index, value):
        self.verbatim.insert(index, value)
    def replace_verbatim_at(self, index, value):
        self.verbatim[index] = value
    def get_javadocliteral(self):
        return self.javadocliteral
    def set_javadocliteral(self, javadocliteral):
        self.javadocliteral = javadocliteral
    def add_javadocliteral(self, value):
        self.javadocliteral.append(value)
    def insert_javadocliteral_at(self, index, value):
        self.javadocliteral.insert(index, value)
    def replace_javadocliteral_at(self, index, value):
        self.javadocliteral[index] = value
    def get_javadoccode(self):
        return self.javadoccode
    def set_javadoccode(self, javadoccode):
        self.javadoccode = javadoccode
    def add_javadoccode(self, value):
        self.javadoccode.append(value)
    def insert_javadoccode_at(self, index, value):
        self.javadoccode.insert(index, value)
    def replace_javadoccode_at(self, index, value):
        self.javadoccode[index] = value
    def get_indexentry(self):
        return self.indexentry
    def set_indexentry(self, indexentry):
        self.indexentry = indexentry
    def add_indexentry(self, value):
        self.indexentry.append(value)
    def insert_indexentry_at(self, index, value):
        self.indexentry.insert(index, value)
    def replace_indexentry_at(self, index, value):
        self.indexentry[index] = value
    def get_orderedlist(self):
        return self.orderedlist
    def set_orderedlist(self, orderedlist):
        self.orderedlist = orderedlist
    def add_orderedlist(self, value):
        self.orderedlist.append(value)
    def insert_orderedlist_at(self, index, value):
        self.orderedlist.insert(index, value)
    def replace_orderedlist_at(self, index, value):
        self.orderedlist[index] = value
    def get_itemizedlist(self):
        return self.itemizedlist
    def set_itemizedlist(self, itemizedlist):
        self.itemizedlist = itemizedlist
    def add_itemizedlist(self, value):
        self.itemizedlist.append(value)
    def insert_itemizedlist_at(self, index, value):
        self.itemizedlist.insert(index, value)
    def replace_itemizedlist_at(self, index, value):
        self.itemizedlist[index] = value
    def get_simplesect(self):
        return self.simplesect
    def set_simplesect(self, simplesect):
        self.simplesect = simplesect
    def add_simplesect(self, value):
        self.simplesect.append(value)
    def insert_simplesect_at(self, index, value):
        self.simplesect.insert(index, value)
    def replace_simplesect_at(self, index, value):
        self.simplesect[index] = value
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_variablelist(self):
        return self.variablelist
    def set_variablelist(self, variablelist):
        self.variablelist = variablelist
    def add_variablelist(self, value):
        self.variablelist.append(value)
    def insert_variablelist_at(self, index, value):
        self.variablelist.insert(index, value)
    def replace_variablelist_at(self, index, value):
        self.variablelist[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_heading(self):
        return self.heading
    def set_heading(self, heading):
        self.heading = heading
    def add_heading(self, value):
        self.heading.append(value)
    def insert_heading_at(self, index, value):
        self.heading.insert(index, value)
    def replace_heading_at(self, index, value):
        self.heading[index] = value
    def get_dotfile(self):
        return self.dotfile
    def set_dotfile(self, dotfile):
        self.dotfile = dotfile
    def add_dotfile(self, value):
        self.dotfile.append(value)
    def insert_dotfile_at(self, index, value):
        self.dotfile.insert(index, value)
    def replace_dotfile_at(self, index, value):
        self.dotfile[index] = value
    def get_mscfile(self):
        return self.mscfile
    def set_mscfile(self, mscfile):
        self.mscfile = mscfile
    def add_mscfile(self, value):
        self.mscfile.append(value)
    def insert_mscfile_at(self, index, value):
        self.mscfile.insert(index, value)
    def replace_mscfile_at(self, index, value):
        self.mscfile[index] = value
    def get_diafile(self):
        return self.diafile
    def set_diafile(self, diafile):
        self.diafile = diafile
    def add_diafile(self, value):
        self.diafile.append(value)
    def insert_diafile_at(self, index, value):
        self.diafile.insert(index, value)
    def replace_diafile_at(self, index, value):
        self.diafile[index] = value
    def get_toclist(self):
        return self.toclist
    def set_toclist(self, toclist):
        self.toclist = toclist
    def add_toclist(self, value):
        self.toclist.append(value)
    def insert_toclist_at(self, index, value):
        self.toclist.insert(index, value)
    def replace_toclist_at(self, index, value):
        self.toclist[index] = value
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def add_language(self, value):
        self.language.append(value)
    def insert_language_at(self, index, value):
        self.language.insert(index, value)
    def replace_language_at(self, index, value):
        self.language[index] = value
    def get_parameterlist(self):
        return self.parameterlist
    def set_parameterlist(self, parameterlist):
        self.parameterlist = parameterlist
    def add_parameterlist(self, value):
        self.parameterlist.append(value)
    def insert_parameterlist_at(self, index, value):
        self.parameterlist.insert(index, value)
    def replace_parameterlist_at(self, index, value):
        self.parameterlist[index] = value
    def get_xrefsect(self):
        return self.xrefsect
    def set_xrefsect(self, xrefsect):
        self.xrefsect = xrefsect
    def add_xrefsect(self, value):
        self.xrefsect.append(value)
    def insert_xrefsect_at(self, index, value):
        self.xrefsect.insert(index, value)
    def replace_xrefsect_at(self, index, value):
        self.xrefsect[index] = value
    def get_copydoc(self):
        return self.copydoc
    def set_copydoc(self, copydoc):
        self.copydoc = copydoc
    def add_copydoc(self, value):
        self.copydoc.append(value)
    def insert_copydoc_at(self, index, value):
        self.copydoc.insert(index, value)
    def replace_copydoc_at(self, index, value):
        self.copydoc[index] = value
    def get_details(self):
        return self.details
    def set_details(self, details):
        self.details = details
    def add_details(self, value):
        self.details.append(value)
    def insert_details_at(self, index, value):
        self.details.insert(index, value)
    def replace_details_at(self, index, value):
        self.details[index] = value
    def get_blockquote(self):
        return self.blockquote
    def set_blockquote(self, blockquote):
        self.blockquote = blockquote
    def add_blockquote(self, value):
        self.blockquote.append(value)
    def insert_blockquote_at(self, index, value):
        self.blockquote.insert(index, value)
    def replace_blockquote_at(self, index, value):
        self.blockquote[index] = value
    def get_parblock(self):
        return self.parblock
    def set_parblock(self, parblock):
        self.parblock = parblock
    def add_parblock(self, value):
        self.parblock.append(value)
    def insert_parblock_at(self, index, value):
        self.parblock.insert(index, value)
    def replace_parblock_at(self, index, value):
        self.parblock[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            self.hruler or
            self.preformatted or
            self.programlisting or
            self.verbatim or
            self.javadocliteral or
            self.javadoccode or
            self.indexentry or
            self.orderedlist or
            self.itemizedlist or
            self.simplesect or
            self.title or
            self.variablelist or
            self.table or
            self.heading or
            self.dotfile or
            self.mscfile or
            self.diafile or
            self.toclist or
            self.language or
            self.parameterlist or
            self.xrefsect or
            self.copydoc or
            self.details or
            self.blockquote or
            self.parblock or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docParaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docParaType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docParaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docParaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docParaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParaType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
        for hruler_ in self.hruler:
            namespaceprefix_ = self.hruler_nsprefix_ + ':' if (UseCapturedNS_ and self.hruler_nsprefix_) else ''
            hruler_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hruler', pretty_print=pretty_print)
        for preformatted_ in self.preformatted:
            namespaceprefix_ = self.preformatted_nsprefix_ + ':' if (UseCapturedNS_ and self.preformatted_nsprefix_) else ''
            preformatted_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='preformatted', pretty_print=pretty_print)
        for programlisting_ in self.programlisting:
            namespaceprefix_ = self.programlisting_nsprefix_ + ':' if (UseCapturedNS_ and self.programlisting_nsprefix_) else ''
            programlisting_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='programlisting', pretty_print=pretty_print)
        for verbatim_ in self.verbatim:
            namespaceprefix_ = self.verbatim_nsprefix_ + ':' if (UseCapturedNS_ and self.verbatim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverbatim>%s</%sverbatim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(verbatim_), input_name='verbatim')), namespaceprefix_ , eol_))
        for javadocliteral_ in self.javadocliteral:
            namespaceprefix_ = self.javadocliteral_nsprefix_ + ':' if (UseCapturedNS_ and self.javadocliteral_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sjavadocliteral>%s</%sjavadocliteral>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(javadocliteral_), input_name='javadocliteral')), namespaceprefix_ , eol_))
        for javadoccode_ in self.javadoccode:
            namespaceprefix_ = self.javadoccode_nsprefix_ + ':' if (UseCapturedNS_ and self.javadoccode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sjavadoccode>%s</%sjavadoccode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(javadoccode_), input_name='javadoccode')), namespaceprefix_ , eol_))
        for indexentry_ in self.indexentry:
            namespaceprefix_ = self.indexentry_nsprefix_ + ':' if (UseCapturedNS_ and self.indexentry_nsprefix_) else ''
            indexentry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='indexentry', pretty_print=pretty_print)
        for orderedlist_ in self.orderedlist:
            namespaceprefix_ = self.orderedlist_nsprefix_ + ':' if (UseCapturedNS_ and self.orderedlist_nsprefix_) else ''
            orderedlist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='orderedlist', pretty_print=pretty_print)
        for itemizedlist_ in self.itemizedlist:
            namespaceprefix_ = self.itemizedlist_nsprefix_ + ':' if (UseCapturedNS_ and self.itemizedlist_nsprefix_) else ''
            itemizedlist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='itemizedlist', pretty_print=pretty_print)
        for simplesect_ in self.simplesect:
            namespaceprefix_ = self.simplesect_nsprefix_ + ':' if (UseCapturedNS_ and self.simplesect_nsprefix_) else ''
            simplesect_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='simplesect', pretty_print=pretty_print)
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for variablelist_ in self.variablelist:
            namespaceprefix_ = self.variablelist_nsprefix_ + ':' if (UseCapturedNS_ and self.variablelist_nsprefix_) else ''
            variablelist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variablelist', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
        for heading_ in self.heading:
            namespaceprefix_ = self.heading_nsprefix_ + ':' if (UseCapturedNS_ and self.heading_nsprefix_) else ''
            heading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='heading', pretty_print=pretty_print)
        for dotfile_ in self.dotfile:
            namespaceprefix_ = self.dotfile_nsprefix_ + ':' if (UseCapturedNS_ and self.dotfile_nsprefix_) else ''
            dotfile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dotfile', pretty_print=pretty_print)
        for mscfile_ in self.mscfile:
            namespaceprefix_ = self.mscfile_nsprefix_ + ':' if (UseCapturedNS_ and self.mscfile_nsprefix_) else ''
            mscfile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mscfile', pretty_print=pretty_print)
        for diafile_ in self.diafile:
            namespaceprefix_ = self.diafile_nsprefix_ + ':' if (UseCapturedNS_ and self.diafile_nsprefix_) else ''
            diafile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='diafile', pretty_print=pretty_print)
        for toclist_ in self.toclist:
            namespaceprefix_ = self.toclist_nsprefix_ + ':' if (UseCapturedNS_ and self.toclist_nsprefix_) else ''
            toclist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toclist', pretty_print=pretty_print)
        for language_ in self.language:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            language_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        for parameterlist_ in self.parameterlist:
            namespaceprefix_ = self.parameterlist_nsprefix_ + ':' if (UseCapturedNS_ and self.parameterlist_nsprefix_) else ''
            parameterlist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parameterlist', pretty_print=pretty_print)
        for xrefsect_ in self.xrefsect:
            namespaceprefix_ = self.xrefsect_nsprefix_ + ':' if (UseCapturedNS_ and self.xrefsect_nsprefix_) else ''
            xrefsect_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='xrefsect', pretty_print=pretty_print)
        for copydoc_ in self.copydoc:
            namespaceprefix_ = self.copydoc_nsprefix_ + ':' if (UseCapturedNS_ and self.copydoc_nsprefix_) else ''
            copydoc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='copydoc', pretty_print=pretty_print)
        for details_ in self.details:
            namespaceprefix_ = self.details_nsprefix_ + ':' if (UseCapturedNS_ and self.details_nsprefix_) else ''
            details_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='details', pretty_print=pretty_print)
        for blockquote_ in self.blockquote:
            namespaceprefix_ = self.blockquote_nsprefix_ + ':' if (UseCapturedNS_ and self.blockquote_nsprefix_) else ''
            blockquote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='blockquote', pretty_print=pretty_print)
        for parblock_ in self.parblock:
            namespaceprefix_ = self.parblock_nsprefix_ + ':' if (UseCapturedNS_ and self.parblock_nsprefix_) else ''
            parblock_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parblock', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        elif nodeName_ == 'hruler':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'hruler', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_hruler'):
                self.add_hruler(obj_.value)
            elif hasattr(self, 'set_hruler'):
                self.set_hruler(obj_.value)
        elif nodeName_ == 'preformatted':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'preformatted', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_preformatted'):
                self.add_preformatted(obj_.value)
            elif hasattr(self, 'set_preformatted'):
                self.set_preformatted(obj_.value)
        elif nodeName_ == 'programlisting':
            obj_ = listingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'programlisting', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_programlisting'):
                self.add_programlisting(obj_.value)
            elif hasattr(self, 'set_programlisting'):
                self.set_programlisting(obj_.value)
        elif nodeName_ == 'verbatim' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'verbatim')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'verbatim')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'verbatim', valuestr_)
            self.content_.append(obj_)
            self.verbatim_nsprefix_ = child_.prefix
        elif nodeName_ == 'javadocliteral' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'javadocliteral')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'javadocliteral')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'javadocliteral', valuestr_)
            self.content_.append(obj_)
            self.javadocliteral_nsprefix_ = child_.prefix
        elif nodeName_ == 'javadoccode' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'javadoccode')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'javadoccode')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'javadoccode', valuestr_)
            self.content_.append(obj_)
            self.javadoccode_nsprefix_ = child_.prefix
        elif nodeName_ == 'indexentry':
            obj_ = docIndexEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'indexentry', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_indexentry'):
                self.add_indexentry(obj_.value)
            elif hasattr(self, 'set_indexentry'):
                self.set_indexentry(obj_.value)
        elif nodeName_ == 'orderedlist':
            obj_ = docListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'orderedlist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_orderedlist'):
                self.add_orderedlist(obj_.value)
            elif hasattr(self, 'set_orderedlist'):
                self.set_orderedlist(obj_.value)
        elif nodeName_ == 'itemizedlist':
            obj_ = docListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'itemizedlist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_itemizedlist'):
                self.add_itemizedlist(obj_.value)
            elif hasattr(self, 'set_itemizedlist'):
                self.set_itemizedlist(obj_.value)
        elif nodeName_ == 'simplesect':
            obj_ = docSimpleSectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'simplesect', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_simplesect'):
                self.add_simplesect(obj_.value)
            elif hasattr(self, 'set_simplesect'):
                self.set_simplesect(obj_.value)
        elif nodeName_ == 'title':
            obj_ = docTitleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'title', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_title'):
                self.add_title(obj_.value)
            elif hasattr(self, 'set_title'):
                self.set_title(obj_.value)
        elif nodeName_ == 'variablelist':
            obj_ = docVariableListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'variablelist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_variablelist'):
                self.add_variablelist(obj_.value)
            elif hasattr(self, 'set_variablelist'):
                self.set_variablelist(obj_.value)
        elif nodeName_ == 'table':
            obj_ = docTableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
                self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
                self.set_table(obj_.value)
        elif nodeName_ == 'heading':
            obj_ = docHeadingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'heading', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_heading'):
                self.add_heading(obj_.value)
            elif hasattr(self, 'set_heading'):
                self.set_heading(obj_.value)
        elif nodeName_ == 'dotfile':
            obj_ = docImageFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dotfile', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dotfile'):
                self.add_dotfile(obj_.value)
            elif hasattr(self, 'set_dotfile'):
                self.set_dotfile(obj_.value)
        elif nodeName_ == 'mscfile':
            obj_ = docImageFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'mscfile', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_mscfile'):
                self.add_mscfile(obj_.value)
            elif hasattr(self, 'set_mscfile'):
                self.set_mscfile(obj_.value)
        elif nodeName_ == 'diafile':
            obj_ = docImageFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'diafile', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_diafile'):
                self.add_diafile(obj_.value)
            elif hasattr(self, 'set_diafile'):
                self.set_diafile(obj_.value)
        elif nodeName_ == 'toclist':
            obj_ = docTocListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'toclist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_toclist'):
                self.add_toclist(obj_.value)
            elif hasattr(self, 'set_toclist'):
                self.set_toclist(obj_.value)
        elif nodeName_ == 'language':
            obj_ = docLanguageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'language', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_language'):
                self.add_language(obj_.value)
            elif hasattr(self, 'set_language'):
                self.set_language(obj_.value)
        elif nodeName_ == 'parameterlist':
            obj_ = docParamListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'parameterlist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_parameterlist'):
                self.add_parameterlist(obj_.value)
            elif hasattr(self, 'set_parameterlist'):
                self.set_parameterlist(obj_.value)
        elif nodeName_ == 'xrefsect':
            obj_ = docXRefSectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'xrefsect', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_xrefsect'):
                self.add_xrefsect(obj_.value)
            elif hasattr(self, 'set_xrefsect'):
                self.set_xrefsect(obj_.value)
        elif nodeName_ == 'copydoc':
            obj_ = docCopyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'copydoc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_copydoc'):
                self.add_copydoc(obj_.value)
            elif hasattr(self, 'set_copydoc'):
                self.set_copydoc(obj_.value)
        elif nodeName_ == 'details':
            obj_ = docDetailsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'details', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_details'):
                self.add_details(obj_.value)
            elif hasattr(self, 'set_details'):
                self.set_details(obj_.value)
        elif nodeName_ == 'blockquote':
            obj_ = docBlockQuoteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'blockquote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_blockquote'):
                self.add_blockquote(obj_.value)
            elif hasattr(self, 'set_blockquote'):
                self.set_blockquote(obj_.value)
        elif nodeName_ == 'parblock':
            obj_ = docParBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'parblock', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_parblock'):
                self.add_parblock(obj_.value)
            elif hasattr(self, 'set_parblock'):
                self.set_parblock(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docParaType


class docMarkupType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, hruler=None, preformatted=None, programlisting=None, verbatim=None, javadocliteral=None, javadoccode=None, indexentry=None, orderedlist=None, itemizedlist=None, simplesect=None, title=None, variablelist=None, table=None, heading=None, dotfile=None, mscfile=None, diafile=None, toclist=None, language=None, parameterlist=None, xrefsect=None, copydoc=None, details=None, blockquote=None, parblock=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        if hruler is None:
            self.hruler = []
        else:
            self.hruler = hruler
        self.hruler_nsprefix_ = None
        if preformatted is None:
            self.preformatted = []
        else:
            self.preformatted = preformatted
        self.preformatted_nsprefix_ = None
        if programlisting is None:
            self.programlisting = []
        else:
            self.programlisting = programlisting
        self.programlisting_nsprefix_ = None
        if verbatim is None:
            self.verbatim = []
        else:
            self.verbatim = verbatim
        self.verbatim_nsprefix_ = None
        if javadocliteral is None:
            self.javadocliteral = []
        else:
            self.javadocliteral = javadocliteral
        self.javadocliteral_nsprefix_ = None
        if javadoccode is None:
            self.javadoccode = []
        else:
            self.javadoccode = javadoccode
        self.javadoccode_nsprefix_ = None
        if indexentry is None:
            self.indexentry = []
        else:
            self.indexentry = indexentry
        self.indexentry_nsprefix_ = None
        if orderedlist is None:
            self.orderedlist = []
        else:
            self.orderedlist = orderedlist
        self.orderedlist_nsprefix_ = None
        if itemizedlist is None:
            self.itemizedlist = []
        else:
            self.itemizedlist = itemizedlist
        self.itemizedlist_nsprefix_ = None
        if simplesect is None:
            self.simplesect = []
        else:
            self.simplesect = simplesect
        self.simplesect_nsprefix_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        self.title_nsprefix_ = None
        if variablelist is None:
            self.variablelist = []
        else:
            self.variablelist = variablelist
        self.variablelist_nsprefix_ = None
        if table is None:
            self.table = []
        else:
            self.table = table
        self.table_nsprefix_ = None
        if heading is None:
            self.heading = []
        else:
            self.heading = heading
        self.heading_nsprefix_ = None
        if dotfile is None:
            self.dotfile = []
        else:
            self.dotfile = dotfile
        self.dotfile_nsprefix_ = None
        if mscfile is None:
            self.mscfile = []
        else:
            self.mscfile = mscfile
        self.mscfile_nsprefix_ = None
        if diafile is None:
            self.diafile = []
        else:
            self.diafile = diafile
        self.diafile_nsprefix_ = None
        if toclist is None:
            self.toclist = []
        else:
            self.toclist = toclist
        self.toclist_nsprefix_ = None
        if language is None:
            self.language = []
        else:
            self.language = language
        self.language_nsprefix_ = None
        if parameterlist is None:
            self.parameterlist = []
        else:
            self.parameterlist = parameterlist
        self.parameterlist_nsprefix_ = None
        if xrefsect is None:
            self.xrefsect = []
        else:
            self.xrefsect = xrefsect
        self.xrefsect_nsprefix_ = None
        if copydoc is None:
            self.copydoc = []
        else:
            self.copydoc = copydoc
        self.copydoc_nsprefix_ = None
        if details is None:
            self.details = []
        else:
            self.details = details
        self.details_nsprefix_ = None
        if blockquote is None:
            self.blockquote = []
        else:
            self.blockquote = blockquote
        self.blockquote_nsprefix_ = None
        if parblock is None:
            self.parblock = []
        else:
            self.parblock = parblock
        self.parblock_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docMarkupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docMarkupType.subclass:
            return docMarkupType.subclass(*args_, **kwargs_)
        else:
            return docMarkupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_hruler(self):
        return self.hruler
    def set_hruler(self, hruler):
        self.hruler = hruler
    def add_hruler(self, value):
        self.hruler.append(value)
    def insert_hruler_at(self, index, value):
        self.hruler.insert(index, value)
    def replace_hruler_at(self, index, value):
        self.hruler[index] = value
    def get_preformatted(self):
        return self.preformatted
    def set_preformatted(self, preformatted):
        self.preformatted = preformatted
    def add_preformatted(self, value):
        self.preformatted.append(value)
    def insert_preformatted_at(self, index, value):
        self.preformatted.insert(index, value)
    def replace_preformatted_at(self, index, value):
        self.preformatted[index] = value
    def get_programlisting(self):
        return self.programlisting
    def set_programlisting(self, programlisting):
        self.programlisting = programlisting
    def add_programlisting(self, value):
        self.programlisting.append(value)
    def insert_programlisting_at(self, index, value):
        self.programlisting.insert(index, value)
    def replace_programlisting_at(self, index, value):
        self.programlisting[index] = value
    def get_verbatim(self):
        return self.verbatim
    def set_verbatim(self, verbatim):
        self.verbatim = verbatim
    def add_verbatim(self, value):
        self.verbatim.append(value)
    def insert_verbatim_at(self, index, value):
        self.verbatim.insert(index, value)
    def replace_verbatim_at(self, index, value):
        self.verbatim[index] = value
    def get_javadocliteral(self):
        return self.javadocliteral
    def set_javadocliteral(self, javadocliteral):
        self.javadocliteral = javadocliteral
    def add_javadocliteral(self, value):
        self.javadocliteral.append(value)
    def insert_javadocliteral_at(self, index, value):
        self.javadocliteral.insert(index, value)
    def replace_javadocliteral_at(self, index, value):
        self.javadocliteral[index] = value
    def get_javadoccode(self):
        return self.javadoccode
    def set_javadoccode(self, javadoccode):
        self.javadoccode = javadoccode
    def add_javadoccode(self, value):
        self.javadoccode.append(value)
    def insert_javadoccode_at(self, index, value):
        self.javadoccode.insert(index, value)
    def replace_javadoccode_at(self, index, value):
        self.javadoccode[index] = value
    def get_indexentry(self):
        return self.indexentry
    def set_indexentry(self, indexentry):
        self.indexentry = indexentry
    def add_indexentry(self, value):
        self.indexentry.append(value)
    def insert_indexentry_at(self, index, value):
        self.indexentry.insert(index, value)
    def replace_indexentry_at(self, index, value):
        self.indexentry[index] = value
    def get_orderedlist(self):
        return self.orderedlist
    def set_orderedlist(self, orderedlist):
        self.orderedlist = orderedlist
    def add_orderedlist(self, value):
        self.orderedlist.append(value)
    def insert_orderedlist_at(self, index, value):
        self.orderedlist.insert(index, value)
    def replace_orderedlist_at(self, index, value):
        self.orderedlist[index] = value
    def get_itemizedlist(self):
        return self.itemizedlist
    def set_itemizedlist(self, itemizedlist):
        self.itemizedlist = itemizedlist
    def add_itemizedlist(self, value):
        self.itemizedlist.append(value)
    def insert_itemizedlist_at(self, index, value):
        self.itemizedlist.insert(index, value)
    def replace_itemizedlist_at(self, index, value):
        self.itemizedlist[index] = value
    def get_simplesect(self):
        return self.simplesect
    def set_simplesect(self, simplesect):
        self.simplesect = simplesect
    def add_simplesect(self, value):
        self.simplesect.append(value)
    def insert_simplesect_at(self, index, value):
        self.simplesect.insert(index, value)
    def replace_simplesect_at(self, index, value):
        self.simplesect[index] = value
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def add_title(self, value):
        self.title.append(value)
    def insert_title_at(self, index, value):
        self.title.insert(index, value)
    def replace_title_at(self, index, value):
        self.title[index] = value
    def get_variablelist(self):
        return self.variablelist
    def set_variablelist(self, variablelist):
        self.variablelist = variablelist
    def add_variablelist(self, value):
        self.variablelist.append(value)
    def insert_variablelist_at(self, index, value):
        self.variablelist.insert(index, value)
    def replace_variablelist_at(self, index, value):
        self.variablelist[index] = value
    def get_table(self):
        return self.table
    def set_table(self, table):
        self.table = table
    def add_table(self, value):
        self.table.append(value)
    def insert_table_at(self, index, value):
        self.table.insert(index, value)
    def replace_table_at(self, index, value):
        self.table[index] = value
    def get_heading(self):
        return self.heading
    def set_heading(self, heading):
        self.heading = heading
    def add_heading(self, value):
        self.heading.append(value)
    def insert_heading_at(self, index, value):
        self.heading.insert(index, value)
    def replace_heading_at(self, index, value):
        self.heading[index] = value
    def get_dotfile(self):
        return self.dotfile
    def set_dotfile(self, dotfile):
        self.dotfile = dotfile
    def add_dotfile(self, value):
        self.dotfile.append(value)
    def insert_dotfile_at(self, index, value):
        self.dotfile.insert(index, value)
    def replace_dotfile_at(self, index, value):
        self.dotfile[index] = value
    def get_mscfile(self):
        return self.mscfile
    def set_mscfile(self, mscfile):
        self.mscfile = mscfile
    def add_mscfile(self, value):
        self.mscfile.append(value)
    def insert_mscfile_at(self, index, value):
        self.mscfile.insert(index, value)
    def replace_mscfile_at(self, index, value):
        self.mscfile[index] = value
    def get_diafile(self):
        return self.diafile
    def set_diafile(self, diafile):
        self.diafile = diafile
    def add_diafile(self, value):
        self.diafile.append(value)
    def insert_diafile_at(self, index, value):
        self.diafile.insert(index, value)
    def replace_diafile_at(self, index, value):
        self.diafile[index] = value
    def get_toclist(self):
        return self.toclist
    def set_toclist(self, toclist):
        self.toclist = toclist
    def add_toclist(self, value):
        self.toclist.append(value)
    def insert_toclist_at(self, index, value):
        self.toclist.insert(index, value)
    def replace_toclist_at(self, index, value):
        self.toclist[index] = value
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def add_language(self, value):
        self.language.append(value)
    def insert_language_at(self, index, value):
        self.language.insert(index, value)
    def replace_language_at(self, index, value):
        self.language[index] = value
    def get_parameterlist(self):
        return self.parameterlist
    def set_parameterlist(self, parameterlist):
        self.parameterlist = parameterlist
    def add_parameterlist(self, value):
        self.parameterlist.append(value)
    def insert_parameterlist_at(self, index, value):
        self.parameterlist.insert(index, value)
    def replace_parameterlist_at(self, index, value):
        self.parameterlist[index] = value
    def get_xrefsect(self):
        return self.xrefsect
    def set_xrefsect(self, xrefsect):
        self.xrefsect = xrefsect
    def add_xrefsect(self, value):
        self.xrefsect.append(value)
    def insert_xrefsect_at(self, index, value):
        self.xrefsect.insert(index, value)
    def replace_xrefsect_at(self, index, value):
        self.xrefsect[index] = value
    def get_copydoc(self):
        return self.copydoc
    def set_copydoc(self, copydoc):
        self.copydoc = copydoc
    def add_copydoc(self, value):
        self.copydoc.append(value)
    def insert_copydoc_at(self, index, value):
        self.copydoc.insert(index, value)
    def replace_copydoc_at(self, index, value):
        self.copydoc[index] = value
    def get_details(self):
        return self.details
    def set_details(self, details):
        self.details = details
    def add_details(self, value):
        self.details.append(value)
    def insert_details_at(self, index, value):
        self.details.insert(index, value)
    def replace_details_at(self, index, value):
        self.details[index] = value
    def get_blockquote(self):
        return self.blockquote
    def set_blockquote(self, blockquote):
        self.blockquote = blockquote
    def add_blockquote(self, value):
        self.blockquote.append(value)
    def insert_blockquote_at(self, index, value):
        self.blockquote.insert(index, value)
    def replace_blockquote_at(self, index, value):
        self.blockquote[index] = value
    def get_parblock(self):
        return self.parblock
    def set_parblock(self, parblock):
        self.parblock = parblock
    def add_parblock(self, value):
        self.parblock.append(value)
    def insert_parblock_at(self, index, value):
        self.parblock.insert(index, value)
    def replace_parblock_at(self, index, value):
        self.parblock[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            self.hruler or
            self.preformatted or
            self.programlisting or
            self.verbatim or
            self.javadocliteral or
            self.javadoccode or
            self.indexentry or
            self.orderedlist or
            self.itemizedlist or
            self.simplesect or
            self.title or
            self.variablelist or
            self.table or
            self.heading or
            self.dotfile or
            self.mscfile or
            self.diafile or
            self.toclist or
            self.language or
            self.parameterlist or
            self.xrefsect or
            self.copydoc or
            self.details or
            self.blockquote or
            self.parblock or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docMarkupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docMarkupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docMarkupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docMarkupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docMarkupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docMarkupType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docMarkupType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
        for hruler_ in self.hruler:
            namespaceprefix_ = self.hruler_nsprefix_ + ':' if (UseCapturedNS_ and self.hruler_nsprefix_) else ''
            hruler_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hruler', pretty_print=pretty_print)
        for preformatted_ in self.preformatted:
            namespaceprefix_ = self.preformatted_nsprefix_ + ':' if (UseCapturedNS_ and self.preformatted_nsprefix_) else ''
            preformatted_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='preformatted', pretty_print=pretty_print)
        for programlisting_ in self.programlisting:
            namespaceprefix_ = self.programlisting_nsprefix_ + ':' if (UseCapturedNS_ and self.programlisting_nsprefix_) else ''
            programlisting_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='programlisting', pretty_print=pretty_print)
        for verbatim_ in self.verbatim:
            namespaceprefix_ = self.verbatim_nsprefix_ + ':' if (UseCapturedNS_ and self.verbatim_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverbatim>%s</%sverbatim>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(verbatim_), input_name='verbatim')), namespaceprefix_ , eol_))
        for javadocliteral_ in self.javadocliteral:
            namespaceprefix_ = self.javadocliteral_nsprefix_ + ':' if (UseCapturedNS_ and self.javadocliteral_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sjavadocliteral>%s</%sjavadocliteral>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(javadocliteral_), input_name='javadocliteral')), namespaceprefix_ , eol_))
        for javadoccode_ in self.javadoccode:
            namespaceprefix_ = self.javadoccode_nsprefix_ + ':' if (UseCapturedNS_ and self.javadoccode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sjavadoccode>%s</%sjavadoccode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(javadoccode_), input_name='javadoccode')), namespaceprefix_ , eol_))
        for indexentry_ in self.indexentry:
            namespaceprefix_ = self.indexentry_nsprefix_ + ':' if (UseCapturedNS_ and self.indexentry_nsprefix_) else ''
            indexentry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='indexentry', pretty_print=pretty_print)
        for orderedlist_ in self.orderedlist:
            namespaceprefix_ = self.orderedlist_nsprefix_ + ':' if (UseCapturedNS_ and self.orderedlist_nsprefix_) else ''
            orderedlist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='orderedlist', pretty_print=pretty_print)
        for itemizedlist_ in self.itemizedlist:
            namespaceprefix_ = self.itemizedlist_nsprefix_ + ':' if (UseCapturedNS_ and self.itemizedlist_nsprefix_) else ''
            itemizedlist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='itemizedlist', pretty_print=pretty_print)
        for simplesect_ in self.simplesect:
            namespaceprefix_ = self.simplesect_nsprefix_ + ':' if (UseCapturedNS_ and self.simplesect_nsprefix_) else ''
            simplesect_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='simplesect', pretty_print=pretty_print)
        for title_ in self.title:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            title_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for variablelist_ in self.variablelist:
            namespaceprefix_ = self.variablelist_nsprefix_ + ':' if (UseCapturedNS_ and self.variablelist_nsprefix_) else ''
            variablelist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='variablelist', pretty_print=pretty_print)
        for table_ in self.table:
            namespaceprefix_ = self.table_nsprefix_ + ':' if (UseCapturedNS_ and self.table_nsprefix_) else ''
            table_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='table', pretty_print=pretty_print)
        for heading_ in self.heading:
            namespaceprefix_ = self.heading_nsprefix_ + ':' if (UseCapturedNS_ and self.heading_nsprefix_) else ''
            heading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='heading', pretty_print=pretty_print)
        for dotfile_ in self.dotfile:
            namespaceprefix_ = self.dotfile_nsprefix_ + ':' if (UseCapturedNS_ and self.dotfile_nsprefix_) else ''
            dotfile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dotfile', pretty_print=pretty_print)
        for mscfile_ in self.mscfile:
            namespaceprefix_ = self.mscfile_nsprefix_ + ':' if (UseCapturedNS_ and self.mscfile_nsprefix_) else ''
            mscfile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mscfile', pretty_print=pretty_print)
        for diafile_ in self.diafile:
            namespaceprefix_ = self.diafile_nsprefix_ + ':' if (UseCapturedNS_ and self.diafile_nsprefix_) else ''
            diafile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='diafile', pretty_print=pretty_print)
        for toclist_ in self.toclist:
            namespaceprefix_ = self.toclist_nsprefix_ + ':' if (UseCapturedNS_ and self.toclist_nsprefix_) else ''
            toclist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toclist', pretty_print=pretty_print)
        for language_ in self.language:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            language_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        for parameterlist_ in self.parameterlist:
            namespaceprefix_ = self.parameterlist_nsprefix_ + ':' if (UseCapturedNS_ and self.parameterlist_nsprefix_) else ''
            parameterlist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parameterlist', pretty_print=pretty_print)
        for xrefsect_ in self.xrefsect:
            namespaceprefix_ = self.xrefsect_nsprefix_ + ':' if (UseCapturedNS_ and self.xrefsect_nsprefix_) else ''
            xrefsect_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='xrefsect', pretty_print=pretty_print)
        for copydoc_ in self.copydoc:
            namespaceprefix_ = self.copydoc_nsprefix_ + ':' if (UseCapturedNS_ and self.copydoc_nsprefix_) else ''
            copydoc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='copydoc', pretty_print=pretty_print)
        for details_ in self.details:
            namespaceprefix_ = self.details_nsprefix_ + ':' if (UseCapturedNS_ and self.details_nsprefix_) else ''
            details_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='details', pretty_print=pretty_print)
        for blockquote_ in self.blockquote:
            namespaceprefix_ = self.blockquote_nsprefix_ + ':' if (UseCapturedNS_ and self.blockquote_nsprefix_) else ''
            blockquote_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='blockquote', pretty_print=pretty_print)
        for parblock_ in self.parblock:
            namespaceprefix_ = self.parblock_nsprefix_ + ':' if (UseCapturedNS_ and self.parblock_nsprefix_) else ''
            parblock_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parblock', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        elif nodeName_ == 'hruler':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'hruler', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_hruler'):
                self.add_hruler(obj_.value)
            elif hasattr(self, 'set_hruler'):
                self.set_hruler(obj_.value)
        elif nodeName_ == 'preformatted':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'preformatted', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_preformatted'):
                self.add_preformatted(obj_.value)
            elif hasattr(self, 'set_preformatted'):
                self.set_preformatted(obj_.value)
        elif nodeName_ == 'programlisting':
            obj_ = listingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'programlisting', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_programlisting'):
                self.add_programlisting(obj_.value)
            elif hasattr(self, 'set_programlisting'):
                self.set_programlisting(obj_.value)
        elif nodeName_ == 'verbatim' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'verbatim')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'verbatim')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'verbatim', valuestr_)
            self.content_.append(obj_)
            self.verbatim_nsprefix_ = child_.prefix
        elif nodeName_ == 'javadocliteral' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'javadocliteral')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'javadocliteral')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'javadocliteral', valuestr_)
            self.content_.append(obj_)
            self.javadocliteral_nsprefix_ = child_.prefix
        elif nodeName_ == 'javadoccode' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'javadoccode')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'javadoccode')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'javadoccode', valuestr_)
            self.content_.append(obj_)
            self.javadoccode_nsprefix_ = child_.prefix
        elif nodeName_ == 'indexentry':
            obj_ = docIndexEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'indexentry', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_indexentry'):
                self.add_indexentry(obj_.value)
            elif hasattr(self, 'set_indexentry'):
                self.set_indexentry(obj_.value)
        elif nodeName_ == 'orderedlist':
            obj_ = docListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'orderedlist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_orderedlist'):
                self.add_orderedlist(obj_.value)
            elif hasattr(self, 'set_orderedlist'):
                self.set_orderedlist(obj_.value)
        elif nodeName_ == 'itemizedlist':
            obj_ = docListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'itemizedlist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_itemizedlist'):
                self.add_itemizedlist(obj_.value)
            elif hasattr(self, 'set_itemizedlist'):
                self.set_itemizedlist(obj_.value)
        elif nodeName_ == 'simplesect':
            obj_ = docSimpleSectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'simplesect', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_simplesect'):
                self.add_simplesect(obj_.value)
            elif hasattr(self, 'set_simplesect'):
                self.set_simplesect(obj_.value)
        elif nodeName_ == 'title':
            obj_ = docTitleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'title', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_title'):
                self.add_title(obj_.value)
            elif hasattr(self, 'set_title'):
                self.set_title(obj_.value)
        elif nodeName_ == 'variablelist':
            obj_ = docVariableListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'variablelist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_variablelist'):
                self.add_variablelist(obj_.value)
            elif hasattr(self, 'set_variablelist'):
                self.set_variablelist(obj_.value)
        elif nodeName_ == 'table':
            obj_ = docTableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'table', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_table'):
                self.add_table(obj_.value)
            elif hasattr(self, 'set_table'):
                self.set_table(obj_.value)
        elif nodeName_ == 'heading':
            obj_ = docHeadingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'heading', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_heading'):
                self.add_heading(obj_.value)
            elif hasattr(self, 'set_heading'):
                self.set_heading(obj_.value)
        elif nodeName_ == 'dotfile':
            obj_ = docImageFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dotfile', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dotfile'):
                self.add_dotfile(obj_.value)
            elif hasattr(self, 'set_dotfile'):
                self.set_dotfile(obj_.value)
        elif nodeName_ == 'mscfile':
            obj_ = docImageFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'mscfile', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_mscfile'):
                self.add_mscfile(obj_.value)
            elif hasattr(self, 'set_mscfile'):
                self.set_mscfile(obj_.value)
        elif nodeName_ == 'diafile':
            obj_ = docImageFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'diafile', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_diafile'):
                self.add_diafile(obj_.value)
            elif hasattr(self, 'set_diafile'):
                self.set_diafile(obj_.value)
        elif nodeName_ == 'toclist':
            obj_ = docTocListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'toclist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_toclist'):
                self.add_toclist(obj_.value)
            elif hasattr(self, 'set_toclist'):
                self.set_toclist(obj_.value)
        elif nodeName_ == 'language':
            obj_ = docLanguageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'language', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_language'):
                self.add_language(obj_.value)
            elif hasattr(self, 'set_language'):
                self.set_language(obj_.value)
        elif nodeName_ == 'parameterlist':
            obj_ = docParamListType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'parameterlist', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_parameterlist'):
                self.add_parameterlist(obj_.value)
            elif hasattr(self, 'set_parameterlist'):
                self.set_parameterlist(obj_.value)
        elif nodeName_ == 'xrefsect':
            obj_ = docXRefSectType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'xrefsect', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_xrefsect'):
                self.add_xrefsect(obj_.value)
            elif hasattr(self, 'set_xrefsect'):
                self.set_xrefsect(obj_.value)
        elif nodeName_ == 'copydoc':
            obj_ = docCopyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'copydoc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_copydoc'):
                self.add_copydoc(obj_.value)
            elif hasattr(self, 'set_copydoc'):
                self.set_copydoc(obj_.value)
        elif nodeName_ == 'details':
            obj_ = docDetailsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'details', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_details'):
                self.add_details(obj_.value)
            elif hasattr(self, 'set_details'):
                self.set_details(obj_.value)
        elif nodeName_ == 'blockquote':
            obj_ = docBlockQuoteType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'blockquote', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_blockquote'):
                self.add_blockquote(obj_.value)
            elif hasattr(self, 'set_blockquote'):
                self.set_blockquote(obj_.value)
        elif nodeName_ == 'parblock':
            obj_ = docParBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'parblock', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_parblock'):
                self.add_parblock(obj_.value)
            elif hasattr(self, 'set_parblock'):
                self.set_parblock(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docMarkupType


class docURLLink(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, url=None, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.url = _cast(None, url)
        self.url_nsprefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docURLLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docURLLink.subclass:
            return docURLLink.subclass(*args_, **kwargs_)
        else:
            return docURLLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docURLLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docURLLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docURLLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docURLLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docURLLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docURLLink'):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.url), input_name='url')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docURLLink', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docURLLink


class docAnchorType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docAnchorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docAnchorType.subclass:
            return docAnchorType.subclass(*args_, **kwargs_)
        else:
            return docAnchorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docAnchorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docAnchorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docAnchorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docAnchorType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docAnchorType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docAnchorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class docAnchorType


class docFormulaType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docFormulaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docFormulaType.subclass:
            return docFormulaType.subclass(*args_, **kwargs_)
        else:
            return docFormulaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docFormulaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docFormulaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docFormulaType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docFormulaType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_, pretty_print=pretty_print)
        outfile.write(self.convert_unicode(self.valueOf_))
        outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docFormulaType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docFormulaType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class docFormulaType


class docIndexEntryType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, primaryie=None, secondaryie=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.primaryie = primaryie
        self.primaryie_nsprefix_ = None
        self.secondaryie = secondaryie
        self.secondaryie_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docIndexEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docIndexEntryType.subclass:
            return docIndexEntryType.subclass(*args_, **kwargs_)
        else:
            return docIndexEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_primaryie(self):
        return self.primaryie
    def set_primaryie(self, primaryie):
        self.primaryie = primaryie
    def get_secondaryie(self):
        return self.secondaryie
    def set_secondaryie(self, secondaryie):
        self.secondaryie = secondaryie
    def hasContent_(self):
        if (
            self.primaryie is not None or
            self.secondaryie is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docIndexEntryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docIndexEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docIndexEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docIndexEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docIndexEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docIndexEntryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docIndexEntryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primaryie is not None:
            namespaceprefix_ = self.primaryie_nsprefix_ + ':' if (UseCapturedNS_ and self.primaryie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprimaryie>%s</%sprimaryie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.primaryie), input_name='primaryie')), namespaceprefix_ , eol_))
        if self.secondaryie is not None:
            namespaceprefix_ = self.secondaryie_nsprefix_ + ':' if (UseCapturedNS_ and self.secondaryie_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecondaryie>%s</%ssecondaryie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.secondaryie), input_name='secondaryie')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'primaryie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'primaryie')
            value_ = self.gds_validate_string(value_, node, 'primaryie')
            self.primaryie = value_
            self.primaryie_nsprefix_ = child_.prefix
        elif nodeName_ == 'secondaryie':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'secondaryie')
            value_ = self.gds_validate_string(value_, node, 'secondaryie')
            self.secondaryie = value_
            self.secondaryie_nsprefix_ = child_.prefix
# end class docIndexEntryType


class docListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, start=None, listitem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.start = _cast(int, start)
        self.start_nsprefix_ = None
        if listitem is None:
            self.listitem = []
        else:
            self.listitem = listitem
        self.listitem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docListType.subclass:
            return docListType.subclass(*args_, **kwargs_)
        else:
            return docListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_listitem(self):
        return self.listitem
    def set_listitem(self, listitem):
        self.listitem = listitem
    def add_listitem(self, value):
        self.listitem.append(value)
    def insert_listitem_at(self, index, value):
        self.listitem.insert(index, value)
    def replace_listitem_at(self, index, value):
        self.listitem[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_start(self):
        return self.start
    def set_start(self, start):
        self.start = start
    def validate_DoxOlType(self, value):
        # Validate type DoxOlType, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['1', 'a', 'A', 'i', 'I']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxOlType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.listitem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docListType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.start is not None and 'start' not in already_processed:
            already_processed.add('start')
            outfile.write(' start="%s"' % self.gds_format_integer(self.start, input_name='start'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for listitem_ in self.listitem:
            namespaceprefix_ = self.listitem_nsprefix_ + ':' if (UseCapturedNS_ and self.listitem_nsprefix_) else ''
            listitem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listitem', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_DoxOlType(self.type_)    # validate type DoxOlType
        value = find_attr_value_('start', node)
        if value is not None and 'start' not in already_processed:
            already_processed.add('start')
            self.start = self.gds_parse_integer(value, node, 'start')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'listitem':
            obj_ = docListItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listitem.append(obj_)
            obj_.original_tagname_ = 'listitem'
# end class docListType


class docListItemType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, value=None, para=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.value = _cast(int, value)
        self.value_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docListItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docListItemType.subclass:
            return docListItemType.subclass(*args_, **kwargs_)
        else:
            return docListItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            self.para
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docListItemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docListItemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docListItemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docListItemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docListItemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docListItemType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docListItemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = self.gds_parse_integer(value, node, 'value')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.para.append(obj_)
            obj_.original_tagname_ = 'para'
# end class docListItemType


class docSimpleSectType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, kind=None, title=None, para=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.kind = _cast(None, kind)
        self.kind_nsprefix_ = None
        self.title = title
        self.title_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docSimpleSectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docSimpleSectType.subclass:
            return docSimpleSectType.subclass(*args_, **kwargs_)
        else:
            return docSimpleSectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def validate_DoxSimpleSectKind(self, value):
        # Validate type DoxSimpleSectKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['see', 'return', 'author', 'authors', 'version', 'since', 'date', 'note', 'warning', 'pre', 'post', 'copyright', 'invariant', 'remark', 'attention', 'par', 'rcs']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxSimpleSectKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.title is not None or
            self.para
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSimpleSectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docSimpleSectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docSimpleSectType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docSimpleSectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docSimpleSectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docSimpleSectType'):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docSimpleSectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            namespaceprefix_ = self.title_nsprefix_ + ':' if (UseCapturedNS_ and self.title_nsprefix_) else ''
            self.title.export(outfile, level, namespaceprefix_, namespacedef_='', name_='title', pretty_print=pretty_print)
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.validate_DoxSimpleSectKind(self.kind)    # validate type DoxSimpleSectKind
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'title':
            obj_ = docTitleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.title = obj_
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.para.append(obj_)
            obj_.original_tagname_ = 'para'
# end class docSimpleSectType


class docVarListEntryType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, term=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.term = term
        self.term_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docVarListEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docVarListEntryType.subclass:
            return docVarListEntryType.subclass(*args_, **kwargs_)
        else:
            return docVarListEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_term(self):
        return self.term
    def set_term(self, term):
        self.term = term
    def hasContent_(self):
        if (
            self.term is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docVarListEntryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docVarListEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docVarListEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docVarListEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docVarListEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docVarListEntryType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docVarListEntryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.term is not None:
            namespaceprefix_ = self.term_nsprefix_ + ':' if (UseCapturedNS_ and self.term_nsprefix_) else ''
            self.term.export(outfile, level, namespaceprefix_, namespacedef_='', name_='term', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'term':
            obj_ = docTitleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.term = obj_
            obj_.original_tagname_ = 'term'
# end class docVarListEntryType


class docVariableListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, varlistentry=None, listitem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if varlistentry is None:
            self.varlistentry = []
        else:
            self.varlistentry = varlistentry
        self.varlistentry_nsprefix_ = None
        if listitem is None:
            self.listitem = []
        else:
            self.listitem = listitem
        self.listitem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docVariableListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docVariableListType.subclass:
            return docVariableListType.subclass(*args_, **kwargs_)
        else:
            return docVariableListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_varlistentry(self):
        return self.varlistentry
    def set_varlistentry(self, varlistentry):
        self.varlistentry = varlistentry
    def add_varlistentry(self, value):
        self.varlistentry.append(value)
    def insert_varlistentry_at(self, index, value):
        self.varlistentry.insert(index, value)
    def replace_varlistentry_at(self, index, value):
        self.varlistentry[index] = value
    def get_listitem(self):
        return self.listitem
    def set_listitem(self, listitem):
        self.listitem = listitem
    def add_listitem(self, value):
        self.listitem.append(value)
    def insert_listitem_at(self, index, value):
        self.listitem.insert(index, value)
    def replace_listitem_at(self, index, value):
        self.listitem[index] = value
    def hasContent_(self):
        if (
            self.varlistentry or
            self.listitem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docVariableListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docVariableListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docVariableListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docVariableListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docVariableListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docVariableListType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docVariableListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for varlistentry_ in self.varlistentry:
            namespaceprefix_ = self.varlistentry_nsprefix_ + ':' if (UseCapturedNS_ and self.varlistentry_nsprefix_) else ''
            varlistentry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='varlistentry', pretty_print=pretty_print)
        for listitem_ in self.listitem:
            namespaceprefix_ = self.listitem_nsprefix_ + ':' if (UseCapturedNS_ and self.listitem_nsprefix_) else ''
            listitem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='listitem', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'varlistentry':
            obj_ = docVarListEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.varlistentry.append(obj_)
            obj_.original_tagname_ = 'varlistentry'
        elif nodeName_ == 'listitem':
            obj_ = docListItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.listitem.append(obj_)
            obj_.original_tagname_ = 'listitem'
# end class docVariableListType


class docRefTextType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refid=None, kindref=None, external=None, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refid = _cast(None, refid)
        self.refid_nsprefix_ = None
        self.kindref = _cast(None, kindref)
        self.kindref_nsprefix_ = None
        self.external = _cast(None, external)
        self.external_nsprefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docRefTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docRefTextType.subclass:
            return docRefTextType.subclass(*args_, **kwargs_)
        else:
            return docRefTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_refid(self):
        return self.refid
    def set_refid(self, refid):
        self.refid = refid
    def get_kindref(self):
        return self.kindref
    def set_kindref(self, kindref):
        self.kindref = kindref
    def get_external(self):
        return self.external
    def set_external(self, external):
        self.external = external
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DoxRefKind(self, value):
        # Validate type DoxRefKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['compound', 'member']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxRefKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docRefTextType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docRefTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docRefTextType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docRefTextType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docRefTextType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docRefTextType'):
        if self.refid is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            outfile.write(' refid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.refid), input_name='refid')), ))
        if self.kindref is not None and 'kindref' not in already_processed:
            already_processed.add('kindref')
            outfile.write(' kindref=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kindref), input_name='kindref')), ))
        if self.external is not None and 'external' not in already_processed:
            already_processed.add('external')
            outfile.write(' external=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.external), input_name='external')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docRefTextType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refid', node)
        if value is not None and 'refid' not in already_processed:
            already_processed.add('refid')
            self.refid = value
        value = find_attr_value_('kindref', node)
        if value is not None and 'kindref' not in already_processed:
            already_processed.add('kindref')
            self.kindref = value
            self.validate_DoxRefKind(self.kindref)    # validate type DoxRefKind
        value = find_attr_value_('external', node)
        if value is not None and 'external' not in already_processed:
            already_processed.add('external')
            self.external = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docRefTextType


class docTableType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, rows=None, cols=None, width=None, caption=None, row=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.rows = _cast(int, rows)
        self.rows_nsprefix_ = None
        self.cols = _cast(int, cols)
        self.cols_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.caption = caption
        self.caption_nsprefix_ = None
        if row is None:
            self.row = []
        else:
            self.row = row
        self.row_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docTableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docTableType.subclass:
            return docTableType.subclass(*args_, **kwargs_)
        else:
            return docTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_row(self):
        return self.row
    def set_row(self, row):
        self.row = row
    def add_row(self, value):
        self.row.append(value)
    def insert_row_at(self, index, value):
        self.row.insert(index, value)
    def replace_row_at(self, index, value):
        self.row[index] = value
    def get_rows(self):
        return self.rows
    def set_rows(self, rows):
        self.rows = rows
    def get_cols(self):
        return self.cols
    def set_cols(self, cols):
        self.cols = cols
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def hasContent_(self):
        if (
            self.caption is not None or
            self.row
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docTableType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docTableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docTableType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docTableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docTableType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docTableType'):
        if self.rows is not None and 'rows' not in already_processed:
            already_processed.add('rows')
            outfile.write(' rows="%s"' % self.gds_format_integer(self.rows, input_name='rows'))
        if self.cols is not None and 'cols' not in already_processed:
            already_processed.add('cols')
            outfile.write(' cols="%s"' % self.gds_format_integer(self.cols, input_name='cols'))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docTableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.caption is not None:
            namespaceprefix_ = self.caption_nsprefix_ + ':' if (UseCapturedNS_ and self.caption_nsprefix_) else ''
            self.caption.export(outfile, level, namespaceprefix_, namespacedef_='', name_='caption', pretty_print=pretty_print)
        for row_ in self.row:
            namespaceprefix_ = self.row_nsprefix_ + ':' if (UseCapturedNS_ and self.row_nsprefix_) else ''
            row_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='row', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rows', node)
        if value is not None and 'rows' not in already_processed:
            already_processed.add('rows')
            self.rows = self.gds_parse_integer(value, node, 'rows')
        value = find_attr_value_('cols', node)
        if value is not None and 'cols' not in already_processed:
            already_processed.add('cols')
            self.cols = self.gds_parse_integer(value, node, 'cols')
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'caption':
            obj_ = docCaptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.caption = obj_
            obj_.original_tagname_ = 'caption'
        elif nodeName_ == 'row':
            obj_ = docRowType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.row.append(obj_)
            obj_.original_tagname_ = 'row'
# end class docTableType


class docRowType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, entry=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if entry is None:
            self.entry = []
        else:
            self.entry = entry
        self.entry_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docRowType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docRowType.subclass:
            return docRowType.subclass(*args_, **kwargs_)
        else:
            return docRowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_entry(self):
        return self.entry
    def set_entry(self, entry):
        self.entry = entry
    def add_entry(self, value):
        self.entry.append(value)
    def insert_entry_at(self, index, value):
        self.entry.insert(index, value)
    def replace_entry_at(self, index, value):
        self.entry[index] = value
    def hasContent_(self):
        if (
            self.entry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docRowType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docRowType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docRowType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docRowType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docRowType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docRowType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docRowType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for entry_ in self.entry:
            namespaceprefix_ = self.entry_nsprefix_ + ':' if (UseCapturedNS_ and self.entry_nsprefix_) else ''
            entry_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entry', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'entry':
            obj_ = docEntryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.entry.append(obj_)
            obj_.original_tagname_ = 'entry'
# end class docRowType


class docEntryType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, thead=None, colspan=None, rowspan=None, align=None, valign=None, width=None, class_=None, para=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.thead = _cast(None, thead)
        self.thead_nsprefix_ = None
        self.colspan = _cast(int, colspan)
        self.colspan_nsprefix_ = None
        self.rowspan = _cast(int, rowspan)
        self.rowspan_nsprefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.valign = _cast(None, valign)
        self.valign_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.class_ = _cast(None, class_)
        self.class__nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docEntryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docEntryType.subclass:
            return docEntryType.subclass(*args_, **kwargs_)
        else:
            return docEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_thead(self):
        return self.thead
    def set_thead(self, thead):
        self.thead = thead
    def get_colspan(self):
        return self.colspan
    def set_colspan(self, colspan):
        self.colspan = colspan
    def get_rowspan(self):
        return self.rowspan
    def set_rowspan(self, rowspan):
        self.rowspan = rowspan
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_valign(self):
        return self.valign
    def set_valign(self, valign):
        self.valign = valign
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_class(self):
        return self.class_
    def set_class(self, class_):
        self.class_ = class_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def validate_DoxBool(self, value):
        # Validate type DoxBool, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxBool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxAlign(self, value):
        # Validate type DoxAlign, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['left', 'right', 'center']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxAlign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxVerticalAlign(self, value):
        # Validate type DoxVerticalAlign, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['bottom', 'top', 'middle']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxVerticalAlign' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.para
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docEntryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docEntryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docEntryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docEntryType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.thead is not None and 'thead' not in already_processed:
            already_processed.add('thead')
            outfile.write(' thead=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.thead), input_name='thead')), ))
        if self.colspan is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            outfile.write(' colspan="%s"' % self.gds_format_integer(self.colspan, input_name='colspan'))
        if self.rowspan is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            outfile.write(' rowspan="%s"' % self.gds_format_integer(self.rowspan, input_name='rowspan'))
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.valign is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            outfile.write(' valign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.valign), input_name='valign')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.class_), input_name='class')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docEntryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('thead', node)
        if value is not None and 'thead' not in already_processed:
            already_processed.add('thead')
            self.thead = value
            self.validate_DoxBool(self.thead)    # validate type DoxBool
        value = find_attr_value_('colspan', node)
        if value is not None and 'colspan' not in already_processed:
            already_processed.add('colspan')
            self.colspan = self.gds_parse_integer(value, node, 'colspan')
        value = find_attr_value_('rowspan', node)
        if value is not None and 'rowspan' not in already_processed:
            already_processed.add('rowspan')
            self.rowspan = self.gds_parse_integer(value, node, 'rowspan')
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
            self.validate_DoxAlign(self.align)    # validate type DoxAlign
        value = find_attr_value_('valign', node)
        if value is not None and 'valign' not in already_processed:
            already_processed.add('valign')
            self.valign = value
            self.validate_DoxVerticalAlign(self.valign)    # validate type DoxVerticalAlign
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.para.append(obj_)
            obj_.original_tagname_ = 'para'
# end class docEntryType


class docCaptionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docCaptionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docCaptionType.subclass:
            return docCaptionType.subclass(*args_, **kwargs_)
        else:
            return docCaptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docCaptionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docCaptionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docCaptionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docCaptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docCaptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docCaptionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docCaptionType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docCaptionType


class docHeadingType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, level=None, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.level = _cast(int, level)
        self.level_nsprefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docHeadingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docHeadingType.subclass:
            return docHeadingType.subclass(*args_, **kwargs_)
        else:
            return docHeadingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docHeadingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docHeadingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docHeadingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docHeadingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docHeadingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docHeadingType'):
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level="%s"' % self.gds_format_integer(self.level, input_name='level'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docHeadingType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = self.gds_parse_integer(value, node, 'level')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docHeadingType


class docImageType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, width=None, height=None, alt=None, inline=None, caption=None, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.height = _cast(None, height)
        self.height_nsprefix_ = None
        self.alt = _cast(None, alt)
        self.alt_nsprefix_ = None
        self.inline = _cast(None, inline)
        self.inline_nsprefix_ = None
        self.caption = _cast(None, caption)
        self.caption_nsprefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docImageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docImageType.subclass:
            return docImageType.subclass(*args_, **kwargs_)
        else:
            return docImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_alt(self):
        return self.alt
    def set_alt(self, alt):
        self.alt = alt
    def get_inline(self):
        return self.inline
    def set_inline(self, inline):
        self.inline = inline
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DoxImageKind(self, value):
        # Validate type DoxImageKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['html', 'latex', 'docbook', 'rtf', 'xml']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxImageKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_DoxBool(self, value):
        # Validate type DoxBool, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxBool' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docImageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docImageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docImageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docImageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docImageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docImageType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.height), input_name='height')), ))
        if self.alt is not None and 'alt' not in already_processed:
            already_processed.add('alt')
            outfile.write(' alt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alt), input_name='alt')), ))
        if self.inline is not None and 'inline' not in already_processed:
            already_processed.add('inline')
            outfile.write(' inline=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inline), input_name='inline')), ))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caption), input_name='caption')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docImageType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_DoxImageKind(self.type_)    # validate type DoxImageKind
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            self.height = value
        value = find_attr_value_('alt', node)
        if value is not None and 'alt' not in already_processed:
            already_processed.add('alt')
            self.alt = value
        value = find_attr_value_('inline', node)
        if value is not None and 'inline' not in already_processed:
            already_processed.add('inline')
            self.inline = value
            self.validate_DoxBool(self.inline)    # validate type DoxBool
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docImageType


class docDotMscType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, width=None, height=None, caption=None, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.height = _cast(None, height)
        self.height_nsprefix_ = None
        self.caption = _cast(None, caption)
        self.caption_nsprefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docDotMscType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docDotMscType.subclass:
            return docDotMscType.subclass(*args_, **kwargs_)
        else:
            return docDotMscType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docDotMscType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docDotMscType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docDotMscType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docDotMscType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docDotMscType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docDotMscType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.height), input_name='height')), ))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caption), input_name='caption')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docDotMscType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            self.height = value
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docDotMscType


class docImageFileType(GeneratedsSuper):
    """The mentioned file will be located in the directory as specified by
    XML_OUTPUT"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, width=None, height=None, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.height = _cast(None, height)
        self.height_nsprefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docImageFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docImageFileType.subclass:
            return docImageFileType.subclass(*args_, **kwargs_)
        else:
            return docImageFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docImageFileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docImageFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docImageFileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docImageFileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docImageFileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docImageFileType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.height), input_name='height')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docImageFileType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            self.height = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docImageFileType


class docPlantumlType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, width=None, height=None, caption=None, engine=None, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.width = _cast(None, width)
        self.width_nsprefix_ = None
        self.height = _cast(None, height)
        self.height_nsprefix_ = None
        self.caption = _cast(None, caption)
        self.caption_nsprefix_ = None
        self.engine = _cast(None, engine)
        self.engine_nsprefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docPlantumlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docPlantumlType.subclass:
            return docPlantumlType.subclass(*args_, **kwargs_)
        else:
            return docPlantumlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_caption(self):
        return self.caption
    def set_caption(self, caption):
        self.caption = caption
    def get_engine(self):
        return self.engine
    def set_engine(self, engine):
        self.engine = engine
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DoxPlantumlEngine(self, value):
        # Validate type DoxPlantumlEngine, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['uml', 'bpm', 'wire', 'dot', 'ditaa', 'salt', 'math', 'latex', 'gantt', 'mindmap', 'wbs', 'yaml', 'creole', 'json', 'flow', 'board', 'git', 'hcl', 'regex', 'ebnf']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxPlantumlEngine' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docPlantumlType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docPlantumlType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docPlantumlType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docPlantumlType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docPlantumlType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docPlantumlType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.width), input_name='width')), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.height), input_name='height')), ))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caption), input_name='caption')), ))
        if self.engine is not None and 'engine' not in already_processed:
            already_processed.add('engine')
            outfile.write(' engine=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.engine), input_name='engine')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docPlantumlType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            self.width = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            self.height = value
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
        value = find_attr_value_('engine', node)
        if value is not None and 'engine' not in already_processed:
            already_processed.add('engine')
            self.engine = value
            self.validate_DoxPlantumlEngine(self.engine)    # validate type DoxPlantumlEngine
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docPlantumlType


class docTocItemType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, ulink=None, bold=None, s=None, strike=None, underline=None, emphasis=None, computeroutput=None, subscript=None, superscript=None, center=None, small=None, cite=None, del_=None, ins=None, htmlonly=None, manonly=None, xmlonly=None, rtfonly=None, latexonly=None, docbookonly=None, image=None, dot=None, msc=None, plantuml=None, anchor=None, formula=None, ref=None, emoji=None, linebreak=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if ulink is None:
            self.ulink = []
        else:
            self.ulink = ulink
        self.ulink_nsprefix_ = None
        if bold is None:
            self.bold = []
        else:
            self.bold = bold
        self.bold_nsprefix_ = None
        if s is None:
            self.s = []
        else:
            self.s = s
        self.s_nsprefix_ = None
        if strike is None:
            self.strike = []
        else:
            self.strike = strike
        self.strike_nsprefix_ = None
        if underline is None:
            self.underline = []
        else:
            self.underline = underline
        self.underline_nsprefix_ = None
        if emphasis is None:
            self.emphasis = []
        else:
            self.emphasis = emphasis
        self.emphasis_nsprefix_ = None
        if computeroutput is None:
            self.computeroutput = []
        else:
            self.computeroutput = computeroutput
        self.computeroutput_nsprefix_ = None
        if subscript is None:
            self.subscript = []
        else:
            self.subscript = subscript
        self.subscript_nsprefix_ = None
        if superscript is None:
            self.superscript = []
        else:
            self.superscript = superscript
        self.superscript_nsprefix_ = None
        if center is None:
            self.center = []
        else:
            self.center = center
        self.center_nsprefix_ = None
        if small is None:
            self.small = []
        else:
            self.small = small
        self.small_nsprefix_ = None
        if cite is None:
            self.cite = []
        else:
            self.cite = cite
        self.cite_nsprefix_ = None
        if del_ is None:
            self.del_ = []
        else:
            self.del_ = del_
        self.del__nsprefix_ = None
        if ins is None:
            self.ins = []
        else:
            self.ins = ins
        self.ins_nsprefix_ = None
        if htmlonly is None:
            self.htmlonly = []
        else:
            self.htmlonly = htmlonly
        self.htmlonly_nsprefix_ = None
        if manonly is None:
            self.manonly = []
        else:
            self.manonly = manonly
        self.manonly_nsprefix_ = None
        if xmlonly is None:
            self.xmlonly = []
        else:
            self.xmlonly = xmlonly
        self.xmlonly_nsprefix_ = None
        if rtfonly is None:
            self.rtfonly = []
        else:
            self.rtfonly = rtfonly
        self.rtfonly_nsprefix_ = None
        if latexonly is None:
            self.latexonly = []
        else:
            self.latexonly = latexonly
        self.latexonly_nsprefix_ = None
        if docbookonly is None:
            self.docbookonly = []
        else:
            self.docbookonly = docbookonly
        self.docbookonly_nsprefix_ = None
        if image is None:
            self.image = []
        else:
            self.image = image
        self.image_nsprefix_ = None
        if dot is None:
            self.dot = []
        else:
            self.dot = dot
        self.dot_nsprefix_ = None
        if msc is None:
            self.msc = []
        else:
            self.msc = msc
        self.msc_nsprefix_ = None
        if plantuml is None:
            self.plantuml = []
        else:
            self.plantuml = plantuml
        self.plantuml_nsprefix_ = None
        if anchor is None:
            self.anchor = []
        else:
            self.anchor = anchor
        self.anchor_nsprefix_ = None
        if formula is None:
            self.formula = []
        else:
            self.formula = formula
        self.formula_nsprefix_ = None
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
        self.ref_nsprefix_ = None
        if emoji is None:
            self.emoji = []
        else:
            self.emoji = emoji
        self.emoji_nsprefix_ = None
        if linebreak is None:
            self.linebreak = []
        else:
            self.linebreak = linebreak
        self.linebreak_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docTocItemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docTocItemType.subclass:
            return docTocItemType.subclass(*args_, **kwargs_)
        else:
            return docTocItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ulink(self):
        return self.ulink
    def set_ulink(self, ulink):
        self.ulink = ulink
    def add_ulink(self, value):
        self.ulink.append(value)
    def insert_ulink_at(self, index, value):
        self.ulink.insert(index, value)
    def replace_ulink_at(self, index, value):
        self.ulink[index] = value
    def get_bold(self):
        return self.bold
    def set_bold(self, bold):
        self.bold = bold
    def add_bold(self, value):
        self.bold.append(value)
    def insert_bold_at(self, index, value):
        self.bold.insert(index, value)
    def replace_bold_at(self, index, value):
        self.bold[index] = value
    def get_s(self):
        return self.s
    def set_s(self, s):
        self.s = s
    def add_s(self, value):
        self.s.append(value)
    def insert_s_at(self, index, value):
        self.s.insert(index, value)
    def replace_s_at(self, index, value):
        self.s[index] = value
    def get_strike(self):
        return self.strike
    def set_strike(self, strike):
        self.strike = strike
    def add_strike(self, value):
        self.strike.append(value)
    def insert_strike_at(self, index, value):
        self.strike.insert(index, value)
    def replace_strike_at(self, index, value):
        self.strike[index] = value
    def get_underline(self):
        return self.underline
    def set_underline(self, underline):
        self.underline = underline
    def add_underline(self, value):
        self.underline.append(value)
    def insert_underline_at(self, index, value):
        self.underline.insert(index, value)
    def replace_underline_at(self, index, value):
        self.underline[index] = value
    def get_emphasis(self):
        return self.emphasis
    def set_emphasis(self, emphasis):
        self.emphasis = emphasis
    def add_emphasis(self, value):
        self.emphasis.append(value)
    def insert_emphasis_at(self, index, value):
        self.emphasis.insert(index, value)
    def replace_emphasis_at(self, index, value):
        self.emphasis[index] = value
    def get_computeroutput(self):
        return self.computeroutput
    def set_computeroutput(self, computeroutput):
        self.computeroutput = computeroutput
    def add_computeroutput(self, value):
        self.computeroutput.append(value)
    def insert_computeroutput_at(self, index, value):
        self.computeroutput.insert(index, value)
    def replace_computeroutput_at(self, index, value):
        self.computeroutput[index] = value
    def get_subscript(self):
        return self.subscript
    def set_subscript(self, subscript):
        self.subscript = subscript
    def add_subscript(self, value):
        self.subscript.append(value)
    def insert_subscript_at(self, index, value):
        self.subscript.insert(index, value)
    def replace_subscript_at(self, index, value):
        self.subscript[index] = value
    def get_superscript(self):
        return self.superscript
    def set_superscript(self, superscript):
        self.superscript = superscript
    def add_superscript(self, value):
        self.superscript.append(value)
    def insert_superscript_at(self, index, value):
        self.superscript.insert(index, value)
    def replace_superscript_at(self, index, value):
        self.superscript[index] = value
    def get_center(self):
        return self.center
    def set_center(self, center):
        self.center = center
    def add_center(self, value):
        self.center.append(value)
    def insert_center_at(self, index, value):
        self.center.insert(index, value)
    def replace_center_at(self, index, value):
        self.center[index] = value
    def get_small(self):
        return self.small
    def set_small(self, small):
        self.small = small
    def add_small(self, value):
        self.small.append(value)
    def insert_small_at(self, index, value):
        self.small.insert(index, value)
    def replace_small_at(self, index, value):
        self.small[index] = value
    def get_cite(self):
        return self.cite
    def set_cite(self, cite):
        self.cite = cite
    def add_cite(self, value):
        self.cite.append(value)
    def insert_cite_at(self, index, value):
        self.cite.insert(index, value)
    def replace_cite_at(self, index, value):
        self.cite[index] = value
    def get_del(self):
        return self.del_
    def set_del(self, del_):
        self.del_ = del_
    def add_del(self, value):
        self.del_.append(value)
    def insert_del_at(self, index, value):
        self.del_.insert(index, value)
    def replace_del_at(self, index, value):
        self.del_[index] = value
    def get_ins(self):
        return self.ins
    def set_ins(self, ins):
        self.ins = ins
    def add_ins(self, value):
        self.ins.append(value)
    def insert_ins_at(self, index, value):
        self.ins.insert(index, value)
    def replace_ins_at(self, index, value):
        self.ins[index] = value
    def get_htmlonly(self):
        return self.htmlonly
    def set_htmlonly(self, htmlonly):
        self.htmlonly = htmlonly
    def add_htmlonly(self, value):
        self.htmlonly.append(value)
    def insert_htmlonly_at(self, index, value):
        self.htmlonly.insert(index, value)
    def replace_htmlonly_at(self, index, value):
        self.htmlonly[index] = value
    def get_manonly(self):
        return self.manonly
    def set_manonly(self, manonly):
        self.manonly = manonly
    def add_manonly(self, value):
        self.manonly.append(value)
    def insert_manonly_at(self, index, value):
        self.manonly.insert(index, value)
    def replace_manonly_at(self, index, value):
        self.manonly[index] = value
    def get_xmlonly(self):
        return self.xmlonly
    def set_xmlonly(self, xmlonly):
        self.xmlonly = xmlonly
    def add_xmlonly(self, value):
        self.xmlonly.append(value)
    def insert_xmlonly_at(self, index, value):
        self.xmlonly.insert(index, value)
    def replace_xmlonly_at(self, index, value):
        self.xmlonly[index] = value
    def get_rtfonly(self):
        return self.rtfonly
    def set_rtfonly(self, rtfonly):
        self.rtfonly = rtfonly
    def add_rtfonly(self, value):
        self.rtfonly.append(value)
    def insert_rtfonly_at(self, index, value):
        self.rtfonly.insert(index, value)
    def replace_rtfonly_at(self, index, value):
        self.rtfonly[index] = value
    def get_latexonly(self):
        return self.latexonly
    def set_latexonly(self, latexonly):
        self.latexonly = latexonly
    def add_latexonly(self, value):
        self.latexonly.append(value)
    def insert_latexonly_at(self, index, value):
        self.latexonly.insert(index, value)
    def replace_latexonly_at(self, index, value):
        self.latexonly[index] = value
    def get_docbookonly(self):
        return self.docbookonly
    def set_docbookonly(self, docbookonly):
        self.docbookonly = docbookonly
    def add_docbookonly(self, value):
        self.docbookonly.append(value)
    def insert_docbookonly_at(self, index, value):
        self.docbookonly.insert(index, value)
    def replace_docbookonly_at(self, index, value):
        self.docbookonly[index] = value
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    def get_dot(self):
        return self.dot
    def set_dot(self, dot):
        self.dot = dot
    def add_dot(self, value):
        self.dot.append(value)
    def insert_dot_at(self, index, value):
        self.dot.insert(index, value)
    def replace_dot_at(self, index, value):
        self.dot[index] = value
    def get_msc(self):
        return self.msc
    def set_msc(self, msc):
        self.msc = msc
    def add_msc(self, value):
        self.msc.append(value)
    def insert_msc_at(self, index, value):
        self.msc.insert(index, value)
    def replace_msc_at(self, index, value):
        self.msc[index] = value
    def get_plantuml(self):
        return self.plantuml
    def set_plantuml(self, plantuml):
        self.plantuml = plantuml
    def add_plantuml(self, value):
        self.plantuml.append(value)
    def insert_plantuml_at(self, index, value):
        self.plantuml.insert(index, value)
    def replace_plantuml_at(self, index, value):
        self.plantuml[index] = value
    def get_anchor(self):
        return self.anchor
    def set_anchor(self, anchor):
        self.anchor = anchor
    def add_anchor(self, value):
        self.anchor.append(value)
    def insert_anchor_at(self, index, value):
        self.anchor.insert(index, value)
    def replace_anchor_at(self, index, value):
        self.anchor[index] = value
    def get_formula(self):
        return self.formula
    def set_formula(self, formula):
        self.formula = formula
    def add_formula(self, value):
        self.formula.append(value)
    def insert_formula_at(self, index, value):
        self.formula.insert(index, value)
    def replace_formula_at(self, index, value):
        self.formula[index] = value
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def add_ref(self, value):
        self.ref.append(value)
    def insert_ref_at(self, index, value):
        self.ref.insert(index, value)
    def replace_ref_at(self, index, value):
        self.ref[index] = value
    def get_emoji(self):
        return self.emoji
    def set_emoji(self, emoji):
        self.emoji = emoji
    def add_emoji(self, value):
        self.emoji.append(value)
    def insert_emoji_at(self, index, value):
        self.emoji.insert(index, value)
    def replace_emoji_at(self, index, value):
        self.emoji[index] = value
    def get_linebreak(self):
        return self.linebreak
    def set_linebreak(self, linebreak):
        self.linebreak = linebreak
    def add_linebreak(self, value):
        self.linebreak.append(value)
    def insert_linebreak_at(self, index, value):
        self.linebreak.insert(index, value)
    def replace_linebreak_at(self, index, value):
        self.linebreak[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ulink or
            self.bold or
            self.s or
            self.strike or
            self.underline or
            self.emphasis or
            self.computeroutput or
            self.subscript or
            self.superscript or
            self.center or
            self.small or
            self.cite or
            self.del_ or
            self.ins or
            self.htmlonly or
            self.manonly or
            self.xmlonly or
            self.rtfonly or
            self.latexonly or
            self.docbookonly or
            self.image or
            self.dot or
            self.msc or
            self.plantuml or
            self.anchor or
            self.formula or
            self.ref or
            self.emoji or
            self.linebreak or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docTocItemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docTocItemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docTocItemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docTocItemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docTocItemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docTocItemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docTocItemType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ulink_ in self.ulink:
            namespaceprefix_ = self.ulink_nsprefix_ + ':' if (UseCapturedNS_ and self.ulink_nsprefix_) else ''
            ulink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ulink', pretty_print=pretty_print)
        for bold_ in self.bold:
            namespaceprefix_ = self.bold_nsprefix_ + ':' if (UseCapturedNS_ and self.bold_nsprefix_) else ''
            bold_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bold', pretty_print=pretty_print)
        for s_ in self.s:
            namespaceprefix_ = self.s_nsprefix_ + ':' if (UseCapturedNS_ and self.s_nsprefix_) else ''
            s_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='s', pretty_print=pretty_print)
        for strike_ in self.strike:
            namespaceprefix_ = self.strike_nsprefix_ + ':' if (UseCapturedNS_ and self.strike_nsprefix_) else ''
            strike_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='strike', pretty_print=pretty_print)
        for underline_ in self.underline:
            namespaceprefix_ = self.underline_nsprefix_ + ':' if (UseCapturedNS_ and self.underline_nsprefix_) else ''
            underline_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='underline', pretty_print=pretty_print)
        for emphasis_ in self.emphasis:
            namespaceprefix_ = self.emphasis_nsprefix_ + ':' if (UseCapturedNS_ and self.emphasis_nsprefix_) else ''
            emphasis_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emphasis', pretty_print=pretty_print)
        for computeroutput_ in self.computeroutput:
            namespaceprefix_ = self.computeroutput_nsprefix_ + ':' if (UseCapturedNS_ and self.computeroutput_nsprefix_) else ''
            computeroutput_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='computeroutput', pretty_print=pretty_print)
        for subscript_ in self.subscript:
            namespaceprefix_ = self.subscript_nsprefix_ + ':' if (UseCapturedNS_ and self.subscript_nsprefix_) else ''
            subscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subscript', pretty_print=pretty_print)
        for superscript_ in self.superscript:
            namespaceprefix_ = self.superscript_nsprefix_ + ':' if (UseCapturedNS_ and self.superscript_nsprefix_) else ''
            superscript_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='superscript', pretty_print=pretty_print)
        for center_ in self.center:
            namespaceprefix_ = self.center_nsprefix_ + ':' if (UseCapturedNS_ and self.center_nsprefix_) else ''
            center_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='center', pretty_print=pretty_print)
        for small_ in self.small:
            namespaceprefix_ = self.small_nsprefix_ + ':' if (UseCapturedNS_ and self.small_nsprefix_) else ''
            small_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='small', pretty_print=pretty_print)
        for cite_ in self.cite:
            namespaceprefix_ = self.cite_nsprefix_ + ':' if (UseCapturedNS_ and self.cite_nsprefix_) else ''
            cite_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cite', pretty_print=pretty_print)
        for del_ in self.del_:
            namespaceprefix_ = self.del__nsprefix_ + ':' if (UseCapturedNS_ and self.del__nsprefix_) else ''
            del_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='del', pretty_print=pretty_print)
        for ins_ in self.ins:
            namespaceprefix_ = self.ins_nsprefix_ + ':' if (UseCapturedNS_ and self.ins_nsprefix_) else ''
            ins_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ins', pretty_print=pretty_print)
        for htmlonly_ in self.htmlonly:
            namespaceprefix_ = self.htmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.htmlonly_nsprefix_) else ''
            htmlonly_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='htmlonly', pretty_print=pretty_print)
        for manonly_ in self.manonly:
            namespaceprefix_ = self.manonly_nsprefix_ + ':' if (UseCapturedNS_ and self.manonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanonly>%s</%smanonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(manonly_), input_name='manonly')), namespaceprefix_ , eol_))
        for xmlonly_ in self.xmlonly:
            namespaceprefix_ = self.xmlonly_nsprefix_ + ':' if (UseCapturedNS_ and self.xmlonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxmlonly>%s</%sxmlonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xmlonly_), input_name='xmlonly')), namespaceprefix_ , eol_))
        for rtfonly_ in self.rtfonly:
            namespaceprefix_ = self.rtfonly_nsprefix_ + ':' if (UseCapturedNS_ and self.rtfonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtfonly>%s</%srtfonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(rtfonly_), input_name='rtfonly')), namespaceprefix_ , eol_))
        for latexonly_ in self.latexonly:
            namespaceprefix_ = self.latexonly_nsprefix_ + ':' if (UseCapturedNS_ and self.latexonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatexonly>%s</%slatexonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(latexonly_), input_name='latexonly')), namespaceprefix_ , eol_))
        for docbookonly_ in self.docbookonly:
            namespaceprefix_ = self.docbookonly_nsprefix_ + ':' if (UseCapturedNS_ and self.docbookonly_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdocbookonly>%s</%sdocbookonly>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(docbookonly_), input_name='docbookonly')), namespaceprefix_ , eol_))
        for image_ in self.image:
            namespaceprefix_ = self.image_nsprefix_ + ':' if (UseCapturedNS_ and self.image_nsprefix_) else ''
            image_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='image', pretty_print=pretty_print)
        for dot_ in self.dot:
            namespaceprefix_ = self.dot_nsprefix_ + ':' if (UseCapturedNS_ and self.dot_nsprefix_) else ''
            dot_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dot', pretty_print=pretty_print)
        for msc_ in self.msc:
            namespaceprefix_ = self.msc_nsprefix_ + ':' if (UseCapturedNS_ and self.msc_nsprefix_) else ''
            msc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='msc', pretty_print=pretty_print)
        for plantuml_ in self.plantuml:
            namespaceprefix_ = self.plantuml_nsprefix_ + ':' if (UseCapturedNS_ and self.plantuml_nsprefix_) else ''
            plantuml_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='plantuml', pretty_print=pretty_print)
        for anchor_ in self.anchor:
            namespaceprefix_ = self.anchor_nsprefix_ + ':' if (UseCapturedNS_ and self.anchor_nsprefix_) else ''
            anchor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='anchor', pretty_print=pretty_print)
        for formula_ in self.formula:
            namespaceprefix_ = self.formula_nsprefix_ + ':' if (UseCapturedNS_ and self.formula_nsprefix_) else ''
            formula_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='formula', pretty_print=pretty_print)
        for ref_ in self.ref:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            ref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
        for emoji_ in self.emoji:
            namespaceprefix_ = self.emoji_nsprefix_ + ':' if (UseCapturedNS_ and self.emoji_nsprefix_) else ''
            emoji_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emoji', pretty_print=pretty_print)
        for linebreak_ in self.linebreak:
            namespaceprefix_ = self.linebreak_nsprefix_ + ':' if (UseCapturedNS_ and self.linebreak_nsprefix_) else ''
            linebreak_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linebreak', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ulink':
            obj_ = docURLLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ulink', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ulink'):
                self.add_ulink(obj_.value)
            elif hasattr(self, 'set_ulink'):
                self.set_ulink(obj_.value)
        elif nodeName_ == 'bold':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'bold', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_bold'):
                self.add_bold(obj_.value)
            elif hasattr(self, 'set_bold'):
                self.set_bold(obj_.value)
        elif nodeName_ == 's':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 's', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_s'):
                self.add_s(obj_.value)
            elif hasattr(self, 'set_s'):
                self.set_s(obj_.value)
        elif nodeName_ == 'strike':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'strike', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_strike'):
                self.add_strike(obj_.value)
            elif hasattr(self, 'set_strike'):
                self.set_strike(obj_.value)
        elif nodeName_ == 'underline':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'underline', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_underline'):
                self.add_underline(obj_.value)
            elif hasattr(self, 'set_underline'):
                self.set_underline(obj_.value)
        elif nodeName_ == 'emphasis':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emphasis', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emphasis'):
                self.add_emphasis(obj_.value)
            elif hasattr(self, 'set_emphasis'):
                self.set_emphasis(obj_.value)
        elif nodeName_ == 'computeroutput':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'computeroutput', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_computeroutput'):
                self.add_computeroutput(obj_.value)
            elif hasattr(self, 'set_computeroutput'):
                self.set_computeroutput(obj_.value)
        elif nodeName_ == 'subscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'subscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_subscript'):
                self.add_subscript(obj_.value)
            elif hasattr(self, 'set_subscript'):
                self.set_subscript(obj_.value)
        elif nodeName_ == 'superscript':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'superscript', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_superscript'):
                self.add_superscript(obj_.value)
            elif hasattr(self, 'set_superscript'):
                self.set_superscript(obj_.value)
        elif nodeName_ == 'center':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'center', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_center'):
                self.add_center(obj_.value)
            elif hasattr(self, 'set_center'):
                self.set_center(obj_.value)
        elif nodeName_ == 'small':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'small', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_small'):
                self.add_small(obj_.value)
            elif hasattr(self, 'set_small'):
                self.set_small(obj_.value)
        elif nodeName_ == 'cite':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cite', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cite'):
                self.add_cite(obj_.value)
            elif hasattr(self, 'set_cite'):
                self.set_cite(obj_.value)
        elif nodeName_ == 'del':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'del', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_del'):
                self.add_del(obj_.value)
            elif hasattr(self, 'set_del'):
                self.set_del(obj_.value)
        elif nodeName_ == 'ins':
            obj_ = docMarkupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ins', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ins'):
                self.add_ins(obj_.value)
            elif hasattr(self, 'set_ins'):
                self.set_ins(obj_.value)
        elif nodeName_ == 'htmlonly':
            obj_ = docHtmlOnlyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'htmlonly', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_htmlonly'):
                self.add_htmlonly(obj_.value)
            elif hasattr(self, 'set_htmlonly'):
                self.set_htmlonly(obj_.value)
        elif nodeName_ == 'manonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'manonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'manonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'manonly', valuestr_)
            self.content_.append(obj_)
            self.manonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'xmlonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'xmlonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'xmlonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'xmlonly', valuestr_)
            self.content_.append(obj_)
            self.xmlonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'rtfonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'rtfonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'rtfonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'rtfonly', valuestr_)
            self.content_.append(obj_)
            self.rtfonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'latexonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'latexonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'latexonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'latexonly', valuestr_)
            self.content_.append(obj_)
            self.latexonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'docbookonly' and child_.text is not None:
            valuestr_ = child_.text
            valuestr_ = self.gds_parse_string(valuestr_, node, 'docbookonly')
            valuestr_ = self.gds_validate_string(valuestr_, node, 'docbookonly')
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'docbookonly', valuestr_)
            self.content_.append(obj_)
            self.docbookonly_nsprefix_ = child_.prefix
        elif nodeName_ == 'image':
            obj_ = docImageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'image', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_image'):
                self.add_image(obj_.value)
            elif hasattr(self, 'set_image'):
                self.set_image(obj_.value)
        elif nodeName_ == 'dot':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'dot', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_dot'):
                self.add_dot(obj_.value)
            elif hasattr(self, 'set_dot'):
                self.set_dot(obj_.value)
        elif nodeName_ == 'msc':
            obj_ = docDotMscType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'msc', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_msc'):
                self.add_msc(obj_.value)
            elif hasattr(self, 'set_msc'):
                self.set_msc(obj_.value)
        elif nodeName_ == 'plantuml':
            obj_ = docPlantumlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'plantuml', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_plantuml'):
                self.add_plantuml(obj_.value)
            elif hasattr(self, 'set_plantuml'):
                self.set_plantuml(obj_.value)
        elif nodeName_ == 'anchor':
            obj_ = docAnchorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'anchor', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_anchor'):
                self.add_anchor(obj_.value)
            elif hasattr(self, 'set_anchor'):
                self.set_anchor(obj_.value)
        elif nodeName_ == 'formula':
            obj_ = docFormulaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'formula', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_formula'):
                self.add_formula(obj_.value)
            elif hasattr(self, 'set_formula'):
                self.set_formula(obj_.value)
        elif nodeName_ == 'ref':
            obj_ = docRefTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        elif nodeName_ == 'emoji':
            obj_ = docEmojiType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'emoji', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_emoji'):
                self.add_emoji(obj_.value)
            elif hasattr(self, 'set_emoji'):
                self.set_emoji(obj_.value)
        elif nodeName_ == 'linebreak':
            obj_ = docEmptyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'linebreak', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_linebreak'):
                self.add_linebreak(obj_.value)
            elif hasattr(self, 'set_linebreak'):
                self.set_linebreak(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docTocItemType


class docTocListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tocitem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if tocitem is None:
            self.tocitem = []
        else:
            self.tocitem = tocitem
        self.tocitem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docTocListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docTocListType.subclass:
            return docTocListType.subclass(*args_, **kwargs_)
        else:
            return docTocListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tocitem(self):
        return self.tocitem
    def set_tocitem(self, tocitem):
        self.tocitem = tocitem
    def add_tocitem(self, value):
        self.tocitem.append(value)
    def insert_tocitem_at(self, index, value):
        self.tocitem.insert(index, value)
    def replace_tocitem_at(self, index, value):
        self.tocitem[index] = value
    def hasContent_(self):
        if (
            self.tocitem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docTocListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docTocListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docTocListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docTocListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docTocListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docTocListType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docTocListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tocitem_ in self.tocitem:
            namespaceprefix_ = self.tocitem_nsprefix_ + ':' if (UseCapturedNS_ and self.tocitem_nsprefix_) else ''
            tocitem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tocitem', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tocitem':
            obj_ = docTocItemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tocitem.append(obj_)
            obj_.original_tagname_ = 'tocitem'
# end class docTocListType


class docLanguageType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, langid=None, para=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.langid = _cast(None, langid)
        self.langid_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docLanguageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docLanguageType.subclass:
            return docLanguageType.subclass(*args_, **kwargs_)
        else:
            return docLanguageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_langid(self):
        return self.langid
    def set_langid(self, langid):
        self.langid = langid
    def hasContent_(self):
        if (
            self.para
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docLanguageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docLanguageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docLanguageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docLanguageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docLanguageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docLanguageType'):
        if self.langid is not None and 'langid' not in already_processed:
            already_processed.add('langid')
            outfile.write(' langid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.langid), input_name='langid')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docLanguageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('langid', node)
        if value is not None and 'langid' not in already_processed:
            already_processed.add('langid')
            self.langid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.para.append(obj_)
            obj_.original_tagname_ = 'para'
# end class docLanguageType


class docParamListType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, kind=None, parameteritem=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.kind = _cast(None, kind)
        self.kind_nsprefix_ = None
        if parameteritem is None:
            self.parameteritem = []
        else:
            self.parameteritem = parameteritem
        self.parameteritem_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docParamListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docParamListType.subclass:
            return docParamListType.subclass(*args_, **kwargs_)
        else:
            return docParamListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_parameteritem(self):
        return self.parameteritem
    def set_parameteritem(self, parameteritem):
        self.parameteritem = parameteritem
    def add_parameteritem(self, value):
        self.parameteritem.append(value)
    def insert_parameteritem_at(self, index, value):
        self.parameteritem.insert(index, value)
    def replace_parameteritem_at(self, index, value):
        self.parameteritem[index] = value
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def validate_DoxParamListKind(self, value):
        # Validate type DoxParamListKind, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['param', 'retval', 'exception', 'templateparam']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxParamListKind' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.parameteritem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParamListType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docParamListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docParamListType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docParamListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docParamListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docParamListType'):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.kind), input_name='kind')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParamListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for parameteritem_ in self.parameteritem:
            namespaceprefix_ = self.parameteritem_nsprefix_ + ':' if (UseCapturedNS_ and self.parameteritem_nsprefix_) else ''
            parameteritem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parameteritem', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.validate_DoxParamListKind(self.kind)    # validate type DoxParamListKind
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'parameteritem':
            obj_ = docParamListItem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameteritem.append(obj_)
            obj_.original_tagname_ = 'parameteritem'
# end class docParamListType


class docParamListItem(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, parameternamelist=None, parameterdescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if parameternamelist is None:
            self.parameternamelist = []
        else:
            self.parameternamelist = parameternamelist
        self.parameternamelist_nsprefix_ = None
        self.parameterdescription = parameterdescription
        self.parameterdescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docParamListItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docParamListItem.subclass:
            return docParamListItem.subclass(*args_, **kwargs_)
        else:
            return docParamListItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_parameternamelist(self):
        return self.parameternamelist
    def set_parameternamelist(self, parameternamelist):
        self.parameternamelist = parameternamelist
    def add_parameternamelist(self, value):
        self.parameternamelist.append(value)
    def insert_parameternamelist_at(self, index, value):
        self.parameternamelist.insert(index, value)
    def replace_parameternamelist_at(self, index, value):
        self.parameternamelist[index] = value
    def get_parameterdescription(self):
        return self.parameterdescription
    def set_parameterdescription(self, parameterdescription):
        self.parameterdescription = parameterdescription
    def hasContent_(self):
        if (
            self.parameternamelist or
            self.parameterdescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParamListItem', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docParamListItem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docParamListItem':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docParamListItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docParamListItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docParamListItem'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParamListItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for parameternamelist_ in self.parameternamelist:
            namespaceprefix_ = self.parameternamelist_nsprefix_ + ':' if (UseCapturedNS_ and self.parameternamelist_nsprefix_) else ''
            parameternamelist_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parameternamelist', pretty_print=pretty_print)
        if self.parameterdescription is not None:
            namespaceprefix_ = self.parameterdescription_nsprefix_ + ':' if (UseCapturedNS_ and self.parameterdescription_nsprefix_) else ''
            self.parameterdescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parameterdescription', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'parameternamelist':
            obj_ = docParamNameList.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameternamelist.append(obj_)
            obj_.original_tagname_ = 'parameternamelist'
        elif nodeName_ == 'parameterdescription':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameterdescription = obj_
            obj_.original_tagname_ = 'parameterdescription'
# end class docParamListItem


class docParamNameList(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, parametertype=None, parametername=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if parametertype is None:
            self.parametertype = []
        else:
            self.parametertype = parametertype
        self.parametertype_nsprefix_ = None
        if parametername is None:
            self.parametername = []
        else:
            self.parametername = parametername
        self.parametername_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docParamNameList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docParamNameList.subclass:
            return docParamNameList.subclass(*args_, **kwargs_)
        else:
            return docParamNameList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_parametertype(self):
        return self.parametertype
    def set_parametertype(self, parametertype):
        self.parametertype = parametertype
    def add_parametertype(self, value):
        self.parametertype.append(value)
    def insert_parametertype_at(self, index, value):
        self.parametertype.insert(index, value)
    def replace_parametertype_at(self, index, value):
        self.parametertype[index] = value
    def get_parametername(self):
        return self.parametername
    def set_parametername(self, parametername):
        self.parametername = parametername
    def add_parametername(self, value):
        self.parametername.append(value)
    def insert_parametername_at(self, index, value):
        self.parametername.insert(index, value)
    def replace_parametername_at(self, index, value):
        self.parametername[index] = value
    def hasContent_(self):
        if (
            self.parametertype or
            self.parametername
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParamNameList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docParamNameList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docParamNameList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docParamNameList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docParamNameList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docParamNameList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParamNameList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for parametertype_ in self.parametertype:
            namespaceprefix_ = self.parametertype_nsprefix_ + ':' if (UseCapturedNS_ and self.parametertype_nsprefix_) else ''
            parametertype_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parametertype', pretty_print=pretty_print)
        for parametername_ in self.parametername:
            namespaceprefix_ = self.parametername_nsprefix_ + ':' if (UseCapturedNS_ and self.parametername_nsprefix_) else ''
            parametername_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='parametername', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'parametertype':
            obj_ = docParamType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parametertype.append(obj_)
            obj_.original_tagname_ = 'parametertype'
        elif nodeName_ == 'parametername':
            obj_ = docParamName.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parametername.append(obj_)
            obj_.original_tagname_ = 'parametername'
# end class docParamNameList


class docParamType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, ref=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.ref = ref
        self.ref_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docParamType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docParamType.subclass:
            return docParamType.subclass(*args_, **kwargs_)
        else:
            return docParamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.ref is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParamType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docParamType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docParamType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docParamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docParamType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docParamType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParamType', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ref is not None:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            self.ref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ref':
            obj_ = refTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docParamType


class docParamName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, direction=None, ref=None, valueOf_=None, mixedclass_=None, content_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.direction = _cast(None, direction)
        self.direction_nsprefix_ = None
        self.ref = ref
        self.ref_nsprefix_ = None
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docParamName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docParamName.subclass:
            return docParamName.subclass(*args_, **kwargs_)
        else:
            return docParamName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_DoxParamDir(self, value):
        # Validate type DoxParamDir, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['in', 'out', 'inout']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on DoxParamDir' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.ref is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            self.content_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParamName', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docParamName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docParamName':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docParamName')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docParamName', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docParamName'):
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            outfile.write(' direction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.direction), input_name='direction')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParamName', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespaceprefix_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ref is not None:
            namespaceprefix_ = self.ref_nsprefix_ + ':' if (UseCapturedNS_ and self.ref_nsprefix_) else ''
            self.ref.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ref', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.add('direction')
            self.direction = value
            self.validate_DoxParamDir(self.direction)    # validate type DoxParamDir
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ref':
            obj_ = refTextType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'ref', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_ref'):
                self.add_ref(obj_.value)
            elif hasattr(self, 'set_ref'):
                self.set_ref(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class docParamName


class docXRefSectType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, xreftitle=None, xrefdescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if xreftitle is None:
            self.xreftitle = []
        else:
            self.xreftitle = xreftitle
        self.xreftitle_nsprefix_ = None
        self.xrefdescription = xrefdescription
        self.xrefdescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docXRefSectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docXRefSectType.subclass:
            return docXRefSectType.subclass(*args_, **kwargs_)
        else:
            return docXRefSectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_xreftitle(self):
        return self.xreftitle
    def set_xreftitle(self, xreftitle):
        self.xreftitle = xreftitle
    def add_xreftitle(self, value):
        self.xreftitle.append(value)
    def insert_xreftitle_at(self, index, value):
        self.xreftitle.insert(index, value)
    def replace_xreftitle_at(self, index, value):
        self.xreftitle[index] = value
    def get_xrefdescription(self):
        return self.xrefdescription
    def set_xrefdescription(self, xrefdescription):
        self.xrefdescription = xrefdescription
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.xreftitle or
            self.xrefdescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docXRefSectType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docXRefSectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docXRefSectType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docXRefSectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docXRefSectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docXRefSectType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docXRefSectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for xreftitle_ in self.xreftitle:
            namespaceprefix_ = self.xreftitle_nsprefix_ + ':' if (UseCapturedNS_ and self.xreftitle_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxreftitle>%s</%sxreftitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(xreftitle_), input_name='xreftitle')), namespaceprefix_ , eol_))
        if self.xrefdescription is not None:
            namespaceprefix_ = self.xrefdescription_nsprefix_ + ':' if (UseCapturedNS_ and self.xrefdescription_nsprefix_) else ''
            self.xrefdescription.export(outfile, level, namespaceprefix_, namespacedef_='', name_='xrefdescription', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'xreftitle':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'xreftitle')
            value_ = self.gds_validate_string(value_, node, 'xreftitle')
            self.xreftitle.append(value_)
            self.xreftitle_nsprefix_ = child_.prefix
        elif nodeName_ == 'xrefdescription':
            obj_ = descriptionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.xrefdescription = obj_
            obj_.original_tagname_ = 'xrefdescription'
# end class docXRefSectType


class docCopyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, link=None, para=None, sect1=None, internal=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.link = _cast(None, link)
        self.link_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
        if sect1 is None:
            self.sect1 = []
        else:
            self.sect1 = sect1
        self.sect1_nsprefix_ = None
        self.internal = internal
        self.internal_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docCopyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docCopyType.subclass:
            return docCopyType.subclass(*args_, **kwargs_)
        else:
            return docCopyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def get_sect1(self):
        return self.sect1
    def set_sect1(self, sect1):
        self.sect1 = sect1
    def add_sect1(self, value):
        self.sect1.append(value)
    def insert_sect1_at(self, index, value):
        self.sect1.insert(index, value)
    def replace_sect1_at(self, index, value):
        self.sect1[index] = value
    def get_internal(self):
        return self.internal
    def set_internal(self, internal):
        self.internal = internal
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def hasContent_(self):
        if (
            self.para or
            self.sect1 or
            self.internal is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docCopyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docCopyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docCopyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docCopyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docCopyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docCopyType'):
        if self.link is not None and 'link' not in already_processed:
            already_processed.add('link')
            outfile.write(' link=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.link), input_name='link')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docCopyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
        for sect1_ in self.sect1:
            namespaceprefix_ = self.sect1_nsprefix_ + ':' if (UseCapturedNS_ and self.sect1_nsprefix_) else ''
            sect1_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sect1', pretty_print=pretty_print)
        if self.internal is not None:
            namespaceprefix_ = self.internal_nsprefix_ + ':' if (UseCapturedNS_ and self.internal_nsprefix_) else ''
            self.internal.export(outfile, level, namespaceprefix_, namespacedef_='', name_='internal', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('link', node)
        if value is not None and 'link' not in already_processed:
            already_processed.add('link')
            self.link = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.para.append(obj_)
            obj_.original_tagname_ = 'para'
        elif nodeName_ == 'sect1':
            obj_ = docSect1Type.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sect1.append(obj_)
            obj_.original_tagname_ = 'sect1'
        elif nodeName_ == 'internal':
            obj_ = docInternalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.internal = obj_
            obj_.original_tagname_ = 'internal'
# end class docCopyType


class docDetailsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, summary=None, para=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.summary = summary
        self.summary_nsprefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docDetailsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docDetailsType.subclass:
            return docDetailsType.subclass(*args_, **kwargs_)
        else:
            return docDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_summary(self):
        return self.summary
    def set_summary(self, summary):
        self.summary = summary
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def hasContent_(self):
        if (
            self.summary is not None or
            self.para
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docDetailsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docDetailsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docDetailsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docDetailsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docDetailsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docDetailsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docDetailsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.summary is not None:
            namespaceprefix_ = self.summary_nsprefix_ + ':' if (UseCapturedNS_ and self.summary_nsprefix_) else ''
            self.summary.export(outfile, level, namespaceprefix_, namespacedef_='', name_='summary', pretty_print=pretty_print)
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'summary':
            obj_ = docSummaryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.summary = obj_
            obj_.original_tagname_ = 'summary'
        elif nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.para.append(obj_)
            obj_.original_tagname_ = 'para'
# end class docDetailsType


class docBlockQuoteType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, para=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docBlockQuoteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docBlockQuoteType.subclass:
            return docBlockQuoteType.subclass(*args_, **kwargs_)
        else:
            return docBlockQuoteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def hasContent_(self):
        if (
            self.para
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docBlockQuoteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docBlockQuoteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docBlockQuoteType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docBlockQuoteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docBlockQuoteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docBlockQuoteType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docBlockQuoteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.para.append(obj_)
            obj_.original_tagname_ = 'para'
# end class docBlockQuoteType


class docParBlockType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, para=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if para is None:
            self.para = []
        else:
            self.para = para
        self.para_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docParBlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docParBlockType.subclass:
            return docParBlockType.subclass(*args_, **kwargs_)
        else:
            return docParBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_para(self):
        return self.para
    def set_para(self, para):
        self.para = para
    def add_para(self, value):
        self.para.append(value)
    def insert_para_at(self, index, value):
        self.para.insert(index, value)
    def replace_para_at(self, index, value):
        self.para[index] = value
    def hasContent_(self):
        if (
            self.para
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParBlockType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docParBlockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docParBlockType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docParBlockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docParBlockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docParBlockType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docParBlockType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for para_ in self.para:
            namespaceprefix_ = self.para_nsprefix_ + ':' if (UseCapturedNS_ and self.para_nsprefix_) else ''
            para_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='para', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'para':
            obj_ = docParaType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.para.append(obj_)
            obj_.original_tagname_ = 'para'
# end class docParBlockType


class docEmptyType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docEmptyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docEmptyType.subclass:
            return docEmptyType.subclass(*args_, **kwargs_)
        else:
            return docEmptyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docEmptyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docEmptyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docEmptyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docEmptyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docEmptyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docEmptyType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docEmptyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class docEmptyType


class tableofcontentsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tocsect=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if tocsect is None:
            self.tocsect = []
        else:
            self.tocsect = tocsect
        self.tocsect_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tableofcontentsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tableofcontentsType.subclass:
            return tableofcontentsType.subclass(*args_, **kwargs_)
        else:
            return tableofcontentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tocsect(self):
        return self.tocsect
    def set_tocsect(self, tocsect):
        self.tocsect = tocsect
    def add_tocsect(self, value):
        self.tocsect.append(value)
    def insert_tocsect_at(self, index, value):
        self.tocsect.insert(index, value)
    def replace_tocsect_at(self, index, value):
        self.tocsect[index] = value
    def hasContent_(self):
        if (
            self.tocsect
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tableofcontentsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tableofcontentsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tableofcontentsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tableofcontentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tableofcontentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tableofcontentsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tableofcontentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tocsect_ in self.tocsect:
            namespaceprefix_ = self.tocsect_nsprefix_ + ':' if (UseCapturedNS_ and self.tocsect_nsprefix_) else ''
            tocsect_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tocsect', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tocsect':
            obj_ = tableofcontentsKindType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tocsect.append(obj_)
            obj_.original_tagname_ = 'tocsect'
# end class tableofcontentsType


class tableofcontentsKindType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, reference=None, tableofcontents=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.reference = reference
        self.reference_nsprefix_ = None
        if tableofcontents is None:
            self.tableofcontents = []
        else:
            self.tableofcontents = tableofcontents
        self.tableofcontents_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tableofcontentsKindType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tableofcontentsKindType.subclass:
            return tableofcontentsKindType.subclass(*args_, **kwargs_)
        else:
            return tableofcontentsKindType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_tableofcontents(self):
        return self.tableofcontents
    def set_tableofcontents(self, tableofcontents):
        self.tableofcontents = tableofcontents
    def add_tableofcontents(self, value):
        self.tableofcontents.append(value)
    def insert_tableofcontents_at(self, index, value):
        self.tableofcontents.insert(index, value)
    def replace_tableofcontents_at(self, index, value):
        self.tableofcontents[index] = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.reference is not None or
            self.tableofcontents
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tableofcontentsKindType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tableofcontentsKindType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'tableofcontentsKindType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tableofcontentsKindType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='tableofcontentsKindType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tableofcontentsKindType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='tableofcontentsKindType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.reference is not None:
            namespaceprefix_ = self.reference_nsprefix_ + ':' if (UseCapturedNS_ and self.reference_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreference>%s</%sreference>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.reference), input_name='reference')), namespaceprefix_ , eol_))
        for tableofcontents_ in self.tableofcontents:
            namespaceprefix_ = self.tableofcontents_nsprefix_ + ':' if (UseCapturedNS_ and self.tableofcontents_nsprefix_) else ''
            tableofcontents_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tableofcontents', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'reference':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reference')
            value_ = self.gds_validate_string(value_, node, 'reference')
            self.reference = value_
            self.reference_nsprefix_ = child_.prefix
        elif nodeName_ == 'tableofcontents':
            obj_ = tableofcontentsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tableofcontents.append(obj_)
            obj_.original_tagname_ = 'tableofcontents'
# end class tableofcontentsKindType


class docEmojiType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, name=None, unicode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.unicode = _cast(None, unicode)
        self.unicode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, docEmojiType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if docEmojiType.subclass:
            return docEmojiType.subclass(*args_, **kwargs_)
        else:
            return docEmojiType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_unicode(self):
        return self.unicode
    def set_unicode(self, unicode):
        self.unicode = unicode
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docEmojiType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('docEmojiType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'docEmojiType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='docEmojiType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='docEmojiType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='docEmojiType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.unicode is not None and 'unicode' not in already_processed:
            already_processed.add('unicode')
            outfile.write(' unicode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unicode), input_name='unicode')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='docEmojiType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('unicode', node)
        if value is not None and 'unicode' not in already_processed:
            already_processed.add('unicode')
            self.unicode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class docEmojiType


GDSClassesMapping = {
    'doxygen': DoxygenType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DoxygenType'
        rootClass = DoxygenType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DoxygenType'
        rootClass = DoxygenType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DoxygenType'
        rootClass = DoxygenType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DoxygenType'
        rootClass = DoxygenType
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from compound import *\n\n')
        sys.stdout.write('import compound as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://www.w3.org/XML/1998/namespace': []}

__all__ = [
    "DoxygenType",
    "MemberType",
    "argsstring",
    "array",
    "attributes",
    "bitfield",
    "childnodeType",
    "codelineType",
    "compoundRefType",
    "compounddefType",
    "declname",
    "definition",
    "defname",
    "descriptionType",
    "docAnchorType",
    "docBlockQuoteType",
    "docCaptionType",
    "docCopyType",
    "docDetailsType",
    "docDotMscType",
    "docEmojiType",
    "docEmptyType",
    "docEntryType",
    "docFormulaType",
    "docHeadingType",
    "docHtmlOnlyType",
    "docImageFileType",
    "docImageType",
    "docIndexEntryType",
    "docInternalS1Type",
    "docInternalS2Type",
    "docInternalS3Type",
    "docInternalS4Type",
    "docInternalType",
    "docLanguageType",
    "docListItemType",
    "docListType",
    "docMarkupType",
    "docParBlockType",
    "docParaType",
    "docParamListItem",
    "docParamListType",
    "docParamName",
    "docParamNameList",
    "docParamType",
    "docPlantumlType",
    "docRefTextType",
    "docRowType",
    "docSect1Type",
    "docSect2Type",
    "docSect3Type",
    "docSect4Type",
    "docSimpleSectType",
    "docSummaryType",
    "docTableType",
    "docTitleType",
    "docTocItemType",
    "docTocListType",
    "docURLLink",
    "docVarListEntryType",
    "docVariableListType",
    "docXRefSectType",
    "edgelabel",
    "enumvalueType",
    "graphType",
    "highlightType",
    "incType",
    "label",
    "linkType",
    "linkedTextType",
    "listingType",
    "listofallmembersType",
    "locationType",
    "memberRefType",
    "memberdefType",
    "name",
    "nodeType",
    "paramType",
    "qualifiedname",
    "qualifier",
    "read",
    "refTextType",
    "refType",
    "referenceType",
    "reimplementType",
    "scope",
    "sectiondefType",
    "spType",
    "tableofcontentsKindType",
    "tableofcontentsType",
    "templateparamlistType",
    "write"
]
