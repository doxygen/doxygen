
#include "dotrunner.h"

#include "util.h"
#include "portable.h"
#include "dot.h"
#include "message.h"
#include "ftextstream.h"
#include "config.h"

#define USE_PDFLATEX          Config_getBool(USE_PDFLATEX)

// since dot silently reproduces the input file when it does not
// support the PNG format, we need to check the result.
void checkDotResult(const char *imgExt, const char *imgName)
{
  if (qstrcmp(imgExt,"png")==0)
  {
    FILE *f = portable_fopen(imgName,"rb");
    if (f)
    {
      char data[4];
      if (fread(data,1,4,f)==4)
      {
        if (!(data[1]=='P' && data[2]=='N' && data[3]=='G'))
        {
          err("Image `%s' produced by dot is not a valid PNG!\n"
            "You should either select a different format "
            "(DOT_IMAGE_FORMAT in the config file) or install a more "
            "recent version of graphviz (1.7+)\n",imgName
          );
        }
      }
      else
      {
        err("Could not read image `%s' generated by dot!\n",imgName);
      }
      fclose(f);
    }
    else
    {
      err("Could not open image `%s' generated by dot!\n",imgName);
    }
  }
}

static bool resetPDFSize(const int width,const int height, const char *base)
{
  QString tmpName = QString::fromUtf8(QCString(base)+".tmp");
  QString patchFile = QString::fromUtf8(QCString(base)+".dot");
  if (!QDir::current().rename(patchFile,tmpName))
  {
    err("Failed to rename file %s to %s!\n",patchFile.data(),tmpName.data());
    return FALSE;
  }
  QFile fi(tmpName);
  QFile fo(patchFile);
  if (!fi.open(IO_ReadOnly)) 
  {
    err("problem opening file %s for patching!\n",tmpName.data());
    QDir::current().rename(tmpName,patchFile);
    return FALSE;
  }
  if (!fo.open(IO_WriteOnly))
  {
    err("problem opening file %s for patching!\n",patchFile.data());
    QDir::current().rename(tmpName,patchFile);
    fi.close();
    return FALSE;
  }
  FTextStream t(&fo);
  const int maxLineLen=100*1024;
  while (!fi.atEnd()) // foreach line
  {
    QCString line(maxLineLen);
    int numBytes = fi.readLine(line.rawData(),maxLineLen);
    if (numBytes<=0)
    {
      break;
    }
    line.resize(numBytes+1);
    if (line.find("LATEX_PDF_SIZE") != -1)
    {
      double scale = (width > height ? width : height)/double(MAX_LATEX_GRAPH_INCH);
      t << "  size=\""<<width/scale << "," <<height/scale <<"\";\n";
    }
    else
      t << line;
  }
  fi.close();
  fo.close();
  // remove temporary file
  QDir::current().remove(tmpName);
  return TRUE;
}

static bool readBoundingBox(const char *fileName,int *width,int *height,bool isEps)
{
  QCString bb = isEps ? QCString("%%PageBoundingBox:") : QCString("/MediaBox [");
  QFile f(fileName);
  if (!f.open(IO_ReadOnly|IO_Raw)) 
  {
    //printf("readBoundingBox: could not open %s\n",fileName);
    return FALSE;
  }
  const int maxLineLen=1024;
  char buf[maxLineLen];
  while (!f.atEnd())
  {
    int numBytes = f.readLine(buf,maxLineLen-1); // read line
    if (numBytes>0)
    {
      buf[numBytes]='\0';
      const char *p = strstr(buf,bb);
      if (p) // found PageBoundingBox or /MediaBox string
      {
        int x,y;
        if (sscanf(p+bb.length(),"%d %d %d %d",&x,&y,width,height)!=4)
        {
          //printf("readBoundingBox sscanf fail\n");
          return FALSE;
        }
        return TRUE;
      }
    }
    else // read error!
    {
      //printf("Read error %d!\n",numBytes);
      return FALSE;
    }
  }
  err("Failed to extract bounding box from generated diagram file %s\n",fileName);
  return FALSE;
}

bool writeVecGfxFigure(FTextStream &out,const QCString &baseName,
  const QCString &figureName)
{
  int width=400,height=550;
  if (USE_PDFLATEX)
  {
    if (!readBoundingBox(figureName+".pdf",&width,&height,FALSE))
    {
      //printf("writeVecGfxFigure()=0\n");
      return FALSE;
    }
  }
  else
  {
    if (!readBoundingBox(figureName+".eps",&width,&height,TRUE))
    {
      //printf("writeVecGfxFigure()=0\n");
      return FALSE;
    }
  }
  //printf("Got PDF/EPS size %d,%d\n",width,height);
  int maxWidth  = 350;  /* approx. page width in points, excl. margins */
  int maxHeight = 550;  /* approx. page height in points, excl. margins */ 
  out << "\\nopagebreak\n"
    "\\begin{figure}[H]\n"
    "\\begin{center}\n"
    "\\leavevmode\n";
  if (width>maxWidth || height>maxHeight) // figure too big for page
  {
    // c*width/maxWidth > c*height/maxHeight, where c=maxWidth*maxHeight>0
    if (width*maxHeight>height*maxWidth)
    {
      out << "\\includegraphics[width=" << maxWidth << "pt]";
    }
    else
    {
      out << "\\includegraphics[height=" << maxHeight << "pt]";
    }
  }
  else
  {
    out << "\\includegraphics[width=" << width << "pt]";
  }

  out << "{" << baseName << "}\n"
    "\\end{center}\n"
    "\\end{figure}\n";

  //printf("writeVecGfxFigure()=1\n");
  return TRUE;
}

bool DotRunner::DOT_CLEANUP;
bool DotRunner::DOT_MULTI_TARGETS;
DotConstString DotRunner::DOT_EXE;

DotRunner::DotRunner(const QCString& absDotName, const QCString& path, const QCString& md5Hash,
  bool checkResult, const QCString& imageName)
  : m_file(absDotName), m_path(path), 
  m_checkResult(checkResult), m_imageName(imageName),
  m_imgExt(getDotImageExtension()), m_md5Hash(md5Hash),
  m_cleanUp(DOT_CLEANUP)
{
  m_jobs.setAutoDelete(TRUE);
}

void DotRunner::addJob(const char *format,const char *output, const char *base)
{
  QCString args = QCString("-T")+format+" -o \""+output+"\"";
  m_jobs.append(new DotConstString(args, base));
}

void DotRunner::addPostProcessing(const char *cmd,const char *args)
{
  m_postCmd.set(cmd);
  m_postArgs.set(args);
}

bool DotRunner::run()
{
  int exitCode=0;
  int width=0,height=0;

  QCString dotArgs;
  QListIterator<DotConstString> li(m_jobs);
  DotConstString *s;
  if (DOT_MULTI_TARGETS)
  {
    dotArgs=QCString("\"")+m_file.data()+"\"";
    for (li.toFirst();(s=li.current());++li)
    {
      dotArgs+=' ';
      dotArgs+=s->data();
    }
    if ((exitCode=portable_system(DOT_EXE.data(),dotArgs,FALSE))!=0) goto error;
    dotArgs=QCString("\"")+m_file.data()+"\"";
    bool redo = FALSE;
    for (li.toFirst();(s=li.current());++li)
    {
      if (s->pdfData())
      {
        if (!readBoundingBox(QCString(s->pdfData())+".pdf",&width,&height,FALSE)) goto error;
        if ((width > MAX_LATEX_GRAPH_SIZE) || (height > MAX_LATEX_GRAPH_SIZE))
        {
          if (!resetPDFSize(width,height,s->pdfData())) goto error;
          dotArgs+=' ';
          dotArgs+=s->data();
          redo = TRUE;
        }
      }
    }
    if (redo)
    {
      if ((exitCode=portable_system(DOT_EXE.data(),dotArgs,FALSE))!=0) goto error;
    }
  }
  else
  {
    for (li.toFirst();(s=li.current());++li)
    {
      dotArgs=QCString("\"")+m_file.data()+"\" "+s->data();
      if ((exitCode=portable_system(DOT_EXE.data(),dotArgs,FALSE))!=0) goto error;
      if (s->pdfData())
      {
        if (!readBoundingBox(QCString(s->pdfData())+".pdf",&width,&height,FALSE)) goto error;
        if ((width > MAX_LATEX_GRAPH_SIZE) || (height > MAX_LATEX_GRAPH_SIZE))
        {
          if (!resetPDFSize(width,height,s->pdfData())) goto error;
          if ((exitCode=portable_system(DOT_EXE.data(),dotArgs,FALSE))!=0) goto error;
        }
      }
    }
  }
  if (!m_postCmd.isEmpty() && portable_system(m_postCmd.data(),m_postArgs.data())!=0)
  {
    err("Problems running '%s' as a post-processing step for dot output\n",m_postCmd.data());
    return FALSE;
  }
  if (m_checkResult)
  {
    checkDotResult(m_imgExt.data(),m_imageName.data());
  }
  if (m_cleanUp) 
  {
    //printf("removing dot file %s\n",m_file.data());
    //QDir(path).remove(file);
    m_cleanupItem.file.set(m_file.data());
    m_cleanupItem.path.set(m_path.data());
  }
  if (!m_md5Hash.isEmpty()) {
    // create checksum file
    int dotPosition = QCString(m_file.data()).findRev('.');
    QCString md5Name;
    if (dotPosition == -1)
    {
      md5Name = QCString(m_file.data()) + ".md5";
    }
    else
    {
      md5Name = QCString(m_file.data()).left(dotPosition) + ".md5";
    }
    QFile f(md5Name);
    if (f.open(IO_WriteOnly))
    {
      f.writeBlock(m_md5Hash.data(),32); 
      f.close();
    }
  }
  return TRUE;
error:
  err("Problems running dot: exit code=%d, command='%s', arguments='%s'\n",
    exitCode,DOT_EXE.data(),dotArgs.data());
  return FALSE;
}


//--------------------------------------------------------------------

void DotRunnerQueue::enqueue(DotRunner *runner)
{
  QMutexLocker locker(&m_mutex);
  m_queue.enqueue(runner);
  m_bufferNotEmpty.wakeAll();
}

DotRunner *DotRunnerQueue::dequeue()
{
  QMutexLocker locker(&m_mutex);
  while (m_queue.isEmpty())
  {
    // wait until something is added to the queue
    m_bufferNotEmpty.wait(&m_mutex);
  }
  DotRunner *result = m_queue.dequeue();
  return result;
}

uint DotRunnerQueue::count() const
{
  QMutexLocker locker(&m_mutex);
  return m_queue.count();
}

//--------------------------------------------------------------------

DotWorkerThread::DotWorkerThread(DotRunnerQueue *queue)
  : m_queue(queue)
{
  m_cleanupItems.setAutoDelete(TRUE);
}

void DotWorkerThread::run()
{
  DotRunner *runner;
  while ((runner=m_queue->dequeue()))
  {
    runner->run();
    const DotRunner::CleanupItem &cleanup = runner->cleanup();
    if (!cleanup.file.isEmpty())
    {
      m_cleanupItems.append(new DotRunner::CleanupItem(cleanup));
    }
  }
}

void DotWorkerThread::cleanup()
{
  QListIterator<DotRunner::CleanupItem> it(m_cleanupItems);
  DotRunner::CleanupItem *ci;
  for (;(ci=it.current());++it)
  {
    QDir(ci->path.data()).remove(ci->file.data());
  }
}

